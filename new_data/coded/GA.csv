Document Title,Abstract,Year,PDF Link,label,code,time
,"// TBD should this be varbinary($1)? //		registerColumnType(Types.VARBINARY,     ""binary($1)"");",,,unknown,yes,1572973051
,// we do not know either type //BLIND GUESS!,,,unknown,yes,1572973049
,"// null or brand new collection // this will also (inefficiently) handle arrays, which have // no snapshot, so we can't do any better",,,unknown,yes,1572973045
,"// Put a placeholder in entries, so we don't recurse back and try to save() the // same object again. QUESTION: should this be done before onSave() is called? // likewise, should it be done before onUpdate()?",,,unknown,yes,1572973039
,"// ignore it; the incoming property could not be found so we // cannot be sure what to do here.  At the very least, the // safest is to simply not apply any dereference toggling...",,,unknown,yes,1572973034
,// we may be screwed here since the collection action is about to execute // and we do not know the final owner key value,,,unknown,yes,1572973029
,"//FIXME we don't have the associated entity table name here, has to be done in a second pass",,,unknown,yes,1572973025
,// we could move this inside if we wanted to // tolerate collection initializations during // collection dirty checking:,,,unknown,yes,1572973024
,// starts with an alias (old style) // semi-bad thing about this: can't re-alias another alias.....,,,unknown,yes,1572973016
,// would be better to use the element-type to determine // whether the old and the new are equal here; the problem being // we do not necessarily have access to the element type in all // cases,,,unknown,yes,1572973012
,// it might still need to apply a collection ordering based on a // many-to-many defined order-by...,,,unknown,yes,1572368585
,// A shallow query is ok (although technically there should be no fetching here...),,,unknown,yes,1572368545
,// we will need to create new entries,,,unknown,yes,1572368493
,// we will need to remove ye olde entries,,,unknown,yes,1572368475
,// todo : for 4.0 //	private static final Logger log = LoggerFactory.getLogger( SQLStatementLogger.class ); // this is the legacy logging 'category'...,,,unknown,yes,1572364414
,"// dirty check against the database snapshot, if possible/necessary",,,unknown,yes,1572364343
,// we need to wrtap the param in a cast(),,,unknown,yes,1572364326
,//need to hydrate it.,,,unknown,yes,1572364323
,// would need an IdentitySet for this!,,,unknown,yes,1572364320
,//implicit polymorphism not supported (would need a union),,,unknown,yes,1572364285
,"// This just handles a particular case of component // projection, perhaps get rid of it and throw an exception",,,unknown,yes,1572364263
,"// Actually the semantics of the next three are really ""Bag"" // Note that, unlike objects, collection insertions, updates, // deletions are not really remembered between flushes. We // just re-use the same Lists for convenience.",,,unknown,yes,1572364237
,"//if there is a user-specified loader, return that //TODO: filters!?",,,unknown,yes,1572364199
,"// otherwise, a trim-specification and/or a trim-character // have been specified;  we need to decide which options // are present and ""do the right thing"" // should leading trim-characters be trimmed? // should trailing trim-characters be trimmed? // the trim-character (what is to be trimmed off?) // the trim-source (from where should it be trimmed?)",,,unknown,yes,1572364144
,// todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodel,,,unknown,yes,1572364082
,"// Needed to bump this up to DotNode, because that is the only thing which currently // knows about the property-ref path in the correct format; it is either this, or // recurse over the DotNodes constructing the property path just like DotNode does // internally",,,unknown,yes,1572364066
,// do a check,,,unknown,yes,1572364045
,// CHECK,,,unknown,yes,1572364043
,// do a check,,,unknown,yes,1572364041
,// CHECK,,,unknown,yes,1572364039
,// CHECK,,,unknown,yes,1572364036
,"//not really necessary, I guess...",,,unknown,yes,1572364018
,// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!,,,unknown,yes,1572364014
,// TODO: skip formulas?,,,unknown,yes,1572363998
,"// if a composite key, use ""( (foo = ? and bar = ?) or (foo = ? and bar = ?) )"" for batching //TODO: unnecessary for databases with ANSI-style joins",,,unknown,yes,1572363991
,// we need to determine the best way to know that two joinables // represent a single many-to-many...,,,unknown,yes,1572363962
,// TODO : shouldnt inserts be Expectations.NONE?,,,unknown,yes,1572363957
,//TODO!!!,,,unknown,yes,1572363954
,//TODO!!!!!!!,,,unknown,yes,1572363953
,//TODO!!!!!!!,,,unknown,yes,1572363951
,//TODO: we could just return all false...,,,unknown,yes,1572363949
,//TODO: we could just return all false...,,,unknown,yes,1572363947
,//TODO!,,,unknown,yes,1572363945
,//TODO: something with formulas...,,,unknown,yes,1572363944
,// TODO:,,,unknown,yes,1572363941
,//TODO:,,,unknown,yes,1572363940
,//TODO: check this....,,,unknown,yes,1572363938
,//TODO!,,,unknown,yes,1572363936
,//TODO,,,unknown,yes,1572363934
,"//TODO: eventually, rowIdName[j]",,,unknown,yes,1572363933
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,"// TODO: here is why we need to make bytecode provider global :( // TODO : again, fix this after HHH-1907 is complete",,,unknown,yes,0
,//should this interface extend PropertyMapping?,,,unknown,yes,0
,// todo : throw exception?,,,unknown,yes,0
,//TODO: code duplication with SingleTableEntityPersister,,,unknown,yes,0
,// TODO: copy/paste from ManyToOneType,,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,"//for backward compatibility, allow a set with no not-null  //element columns, using all columns in the row locater SQL //TODO: create an implicit not null constraint on all cols?",,,unknown,yes,0
,// TODO : what amount of significant digits need to be supported here? //      - from the DecimalFormat docs: //          [significant digits] = [minimum integer digits] + [maximum fraction digits],,,unknown,yes,0
,"//TODO: make EntityPersister *not* depend on SessionFactoryImplementor //interface, if possible",,,unknown,yes,0
,// todo : throw exception?  maybe warn if not the same?,,,unknown,yes,0
,// worrying about proxies is perhaps a little bit of overkill here...,,,unknown,yes,0
,// Make sure this is a defined parameter and check the incoming value type // TODO: what should be the actual exception type here?,,,unknown,yes,0
,//TODO: get SQL rendering out of here,,,unknown,yes,0
,//This is not very nice (and quite slow):,,,unknown,yes,0
,"// polymorphism not really handled completely correctly, // perhaps...well, actually its ok, assuming that the // entity name used in the lookup is the same as the // the one used here, which it will be",,,unknown,yes,0
,//TODO: add a CriteriaImplementor interface //      this class depends directly upon CriteriaImpl in the impl package...,,,unknown,yes,0
,"// some messy, complex stuff here, since createCriteria() can take an // aliased path, or a path rooted at the creating criteria instance",,,unknown,yes,0
,//TODO: the i==entitySpan-1 bit depends upon subclass implementation (very bad),,,unknown,yes,0
,// would be great to move all this below here into another method that could also be used // from the new scrolling stuff. // // Would need to change the way the max-row stuff is handled (i.e. behind an interface) so // that I could do the control breaking at the means to know when to stop,,,unknown,yes,0
,//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!,,,unknown,yes,0
,"//TODO: Yuck! This is not quite good enough, it's a quick //hack around the problem of having a to-one association //that refers to an embedded component:",,,unknown,yes,0
,"// TODO: Should this really return null?  If not, figure out something better to do here.",,,unknown,yes,0
,//TODO: implement caching?! proxies?!,,,unknown,yes,0
,//TODO: design new lifecycle for ProxyFactory,,,unknown,yes,0
,// todo : this eventually needs to be removed,,,unknown,yes,0
,//TODO: need some caching scheme? really comes down to decision  //      regarding amount of state (if any) kept on PropertyAccessors,,,unknown,yes,0
,//Yuck:,,,unknown,yes,0
,//TODO: perhaps this should be some other RuntimeException...,,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,//TODO: make this a bit nicer,,,unknown,yes,0
,//create an index on the key columns??,,,unknown,yes,0
,//TODO: remove use of instanceof!,,,unknown,yes,0
,// todo : remove,,,unknown,yes,0
,//TODO: is there a more elegant way than downcasting?,,,unknown,yes,0
,"//SPACES //TODO: i'm not sure, but perhaps we should exclude //      abstract denormalized tables?",,,unknown,yes,0
,//TODO: would be nice to handle proxy classes elegantly!,,,unknown,yes,0
,"//TODO: move these to a new JoinableType abstract class, //extended by EntityType and PersistentCollectionType:",,,unknown,yes,0
,// TODO: Fix this so it will work for non-POJO entity mode,,,unknown,yes,0
,"/**	 * @return collection removal	 * FIXME: even if isInverse=""true""?	 */",,,unknown,yes,0
,"//TODO: this is a bit arbitrary, expose a switch to the user?",,,unknown,yes,0
,"//TODO: this is a little inefficient, don't need to do a whole //      deep replaceElements() call",,,unknown,yes,0
,// is this really necessary?,,,unknown,yes,0
,// TODO : YUCK!!!  fix after HHH-1907 is complete,,,unknown,yes,0
,//TODO: temporary,,,unknown,yes,0
,//workaround for WebLogic,,,unknown,yes,0
,// Need a better way to define the suffixes here...,,,unknown,yes,0
,// TODO: something much better - look at the type of the other expression! // TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.,,,unknown,yes,0
,"// todo : should this get moved to PersistentContext? // logically, is PersistentContext the ""thing"" to which an interceptor gets attached?",,,unknown,yes,0
,"// We should reengineer this class so that, rather than the current ad - // hoc linear approach to processing a stream of tokens, we instead // build up a tree of expressions.",,,unknown,yes,0
,// todo : remove,,,unknown,yes,0
,// TODO : this constructor form is *only* used from constructor directly below us; can it go away?,,,unknown,yes,0
,"// TODO: Figure out a better way to get the FROM elements in a proper tree structure. // If this is not the destination of a many-to-many, add it as a child of the origin.",,,unknown,yes,0
,//note that i parameter is now unused (delete it?),,,unknown,yes,0
,// todo : potentially look at optimizing these two arrays,,,unknown,yes,0
,// yuck!,,,unknown,yes,0
,//TODO: make this a bit nicer,,,unknown,yes,0
,//yuck!,,,unknown,yes,0
,"//TODO: implement functionality //  this might be painful to do here, as the ""join post processing"" for //  the subquery has already been performed (meaning that for //  theta-join dialects, the join conditions have already been moved //  over to the where clause).  A ""simple"" solution here might to //  perform ""join post processing"" once for the entire query (including //  any subqueries) at one fell swoop",,,unknown,yes,0
,//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....,,,unknown,yes,0
,// try block is a hack around fact that currently tuplizers are not // given the opportunity to resolve a subclass entity name.  this // allows the (we assume custom) interceptor the ability to // influence this decision if we were not able to based on the // given entityName,,,unknown,yes,0
,"// not absolutely necessary, but does help with aggressive release",,,unknown,yes,0
,// short-circuit for performance...,,,unknown,yes,0
,"// We would probably refactor to have LogicParser (builds a tree of simple // expressions connected by and, or, not), ExpressionParser (translates // from OO terms like foo, foo.Bar, foo.Bar.Baz to SQL terms like // FOOS.ID, FOOS.BAR_ID, etc) and PathExpressionParser (which does much // the same thing it does now)",,,unknown,yes,0
,"// TODO: get SQL rendering out of here, create an AST for the join expressions. // Use the SQL generator grammar to generate the SQL text for the index expression.",,,unknown,yes,0
,// TODO : we may also want to check that the types here map to exactly one column/JDBC-type //      can't think of a situation where arithmetic expression between multi-column mappings //      makes any sense.,,,unknown,yes,0
,//TODO: this class does too many things! we need a different //kind of path expression parser for each of the diffferent //ways in which path expressions can occur,,,unknown,yes,0
,//TODO: optimize this better!,,,unknown,yes,0
,//TODO: should we allow suffixes on these ?,,,unknown,yes,0
,// FIXME Hacky workaround to JBCACHE-1202,,,unknown,yes,0
,//TODO: reuse the PreLoadEvent,,,unknown,yes,0
,//work around a bug in all known connection pools....,,,unknown,yes,0
,"// Needed the ""clazz_"" check to work around union-subclasses // TODO : is there a way to tell whether a persister is truly discrim-column based inheritence?",,,unknown,yes,0
,// TODO : should remove this exposure //  and have all references to the session's batcher use the ConnectionManager.,,,unknown,yes,0
,//We should actually rework this class to not implement Parser //and just process path expressions in the most convenient way.,,,unknown,yes,0
,//Must be done here because of side-effect! yuck...,,,unknown,yes,0
,"// todo : need to find a clean way to handle the ""event source"" role // a seperate classs responsible for generating/dispatching events just duplicates most of the Session methods... // passing around seperate reto interceptor, factory, actionQueue, and persistentContext is not manageable...",,,unknown,yes,0
,"//TODO: COPY/PASTE FROM SessionImpl, pull up!",,,unknown,yes,0
,"// ugly hack for cases like ""elements(foo.bar.collection)"" // (multi-part path expression ending in elements or indices)",,,unknown,yes,0
,//TODO: is this really necessary????,,,unknown,yes,0
,"//put() has nowait semantics, is this really appropriate? //note that it needs to be async replication, never local or sync",,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,//real hacky... // used to count the nesting of parentheses,,,unknown,yes,0
,//name from a super query (a bit inelegant that it shows up here),,,unknown,yes,0
,// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash; // currently not doable though because of the resultset-ref stuff...,,,unknown,yes,0
,//The class is now way to complex!,,,unknown,yes,0
,//TODO: is there a better way?,,,unknown,yes,0
,// TODO : not sure the best way to handle this. // The non-performant way :,,,unknown,yes,0
,"// todo: we should really just collect these from the various SelectExpressions, rather than regenerating here",,,unknown,yes,0
,// todo : should seriously consider not allowing a txn to begin from a child session //      can always route the request to the root session...,,,unknown,yes,0
,// implicit joins are always(?) ok to reuse,,,unknown,yes,0
,"// work around that crazy issue where the tree contains // ""empty"" FromElements (no text); afaict, this is caused // by FromElementFactory.createCollectionJoin()",,,unknown,yes,0
,// this is called by SessionFactory irregardless; we just disregard here; // could also add a check to SessionFactory to only conditionally call stop,,,unknown,yes,0
,// todo : temporary //      needed because currently persister is the one that //      creates and renders the join fragments for inheritence //      hierarchies...,,,unknown,yes,0
,// TODO : keep seperate notions of QT[] here for shallow/non-shallow queries...,,,unknown,yes,0
,//TODO:refactor + make this method private,,,unknown,yes,0
,// TODO: an alternative is to check if the owner has changed; if it hasn't then // get the ID from collection.getOwner(),,,unknown,yes,0
,//TODO: inefficient if that cache is just going to ignore the updated state!,,,unknown,yes,0
,"// for DOM4J ""collections"" only // TODO: it would be better if this was done at the higher level by Printer",,,unknown,yes,0
,//TODO: need to make the majority of this functionality into a top-level support class for custom impl support,,,unknown,yes,0
,// NOTE VERY HACKISH WORKAROUND!! // TODO: Fix this so it will work for non-POJO entity mode,,,unknown,yes,0
,//yukky! Don't you have subclasses for that! //TODO race conditions can happen here,,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,"//TODO: We probably should have a StatisticsNotPublishedException, to make it clean",,,unknown,yes,0
,// Do we need to qualify index names with the schema name?,,,unknown,yes,0
,"//TODO: this class depends directly upon CriteriaImpl,  //      in the impl package ... add a CriteriaImplementor  //      interface",,,unknown,yes,0
,"// from the collection of associations, locate OJA for the // ManyToOne corresponding to this persister to fully // define the many-to-many; we need that OJA so that we can // use its alias here // TODO : is there a better way here?",,,unknown,yes,0
,"//note that this method could easily be moved up to BasicEntityPersister, //if we ever needed to reuse it from other subclasses",,,unknown,yes,0
,//TODO: *two* hashmap lookups here is one too many...,,,unknown,yes,0
,//TODO: refactor to .sql package,,,unknown,yes,0
,//TODO: code duplication with JoinedSubclassEntityPersister,,,unknown,yes,0
,//swaldman 2004-02-07: modify to allow null values to signify fall through to c3p0 PoolConfig defaults,,,unknown,yes,0
,"//kinda ugly, but needed for collections with a ""."" node mapping",,,unknown,yes,0
,"// should indicate that we are processing an INSERT/UPDATE/DELETE // query with a subquery implied via a collection property // function. Here, we need to use the table name itself as the // qualification alias. // TODO : verify this works for all databases... // TODO : is this also the case in non-""indexed"" scenarios?",,,unknown,yes,0
,//FIXME: get the PersistentClass,,,unknown,yes,0
,"// todo : should really move this log statement to CollectionType, where this is used from...",,,unknown,yes,0
,// TODO should we just collect these like with the collections above?,,,unknown,yes,0
,"//TODO: move into collection type, so we can use polymorphism!",,,unknown,yes,0
,//use of a stringbuffer to workaround a JDK bug,,,unknown,yes,0
,// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried // to remove that unqoting and missing aliases..,,,unknown,yes,0
,/////////////////////////////////////////////////////////////////////////// // USED ONLY FOR REGRESSION TESTING!!!! // // todo : obviously get rid of all this junk ;) ///////////////////////////////////////////////////////////////////////////,,,unknown,yes,0
,//TODO: is this 100% correct?,,,unknown,yes,0
,"/** Create an action that will evict collection and entity regions based on queryspaces (table names).	 *  TODO: cache the autodetected information and pass it in instead.	 **/",,,unknown,yes,0
,//TODO: should we use SELECT .. FOR UPDATE?,,,unknown,yes,0
,// todo : modify the class definition if not already transformed...,,,unknown,yes,0
,"//This is really ugly, but necessary:",,,unknown,yes,0
,// append the SQL to return the generated identifier //TODO: suck into Insert,,,unknown,yes,0
,//ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties,,,unknown,yes,0
,//TODO: I am not so sure about the exception handling in this bit!,,,unknown,yes,0
,"//TODO: move to .sql package, and refactor with similar things!",,,unknown,yes,0
,//index += getPropertyColumnSpan( i ); //TODO:  this is kinda slow...,,,unknown,yes,0
,//TODO: is this really necessary????,,,unknown,yes,0
,// entity name will not be available for non-POJO entities // TODO: cache the entity name somewhere so that it is available to this exception,,,unknown,yes,0
,"// TODO : would be great to have a Mapping#hasNonIdentifierPropertyNamedId method // I don't believe that Mapping#getReferencedPropertyType accounts for the identifier property; so // if it returns for a property named 'id', then we should have a non-id field named id",,,unknown,yes,0
,//TODO possibly relax that,,,unknown,yes,0
,//TODO possibly relax that,,,unknown,yes,0
,// TODO : add this info to the translator and aggregate it here...,,,unknown,yes,0
,//TODO: look at the owning property and check that it  //      isn't lazy (by instrumentation),,,unknown,yes,0
,//TODO: does this really need to be here? //      does the collection already have //      it's own up-to-date snapshot?,,,unknown,yes,0
,/* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */,,,unknown,yes,0
,"//TODO: we use two visitors here, inefficient!",,,unknown,yes,0
,//TODO: this needn't exclude subclasses...,,,unknown,yes,0
,/* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */,,,unknown,yes,0
,//this is kinda the best we can do...,,,unknown,yes,0
,//TODO: not quite sure about the full implications of this!,,,unknown,yes,0
,//TODO: put this stuff back in to read snapshot from //      the second-level cache (needs some extra work),,,unknown,yes,0
,"//TODO: if object was an uninitialized proxy, this is inefficient, //      resulting in two SQL selects",,,unknown,yes,0
,"// TODO: The order in which entities are saved may matter (e.g., a particular transient entity //       may need to be saved before other transient entities can be saved; //       Keep retrying the batch of transient entities until either: //       1) there are no transient entities left in transientCopyCache //       or 2) no transient entities were saved in the last batch // For now, just run through the transient entities and retry the merge",,,unknown,yes,0
,"//TODO: we should throw an exception if we really *know* for sure   //      that this is a detached instance, rather than just assuming //throw new StaleObjectStateException(entityName, id);",,,unknown,yes,0
,"//before cascade! //TODO: should this be Session.instantiate(Persister, ...)?",,,unknown,yes,0
,// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried // to remove that unqoting and missing aliases..,,,unknown,yes,0
,// perhaps this should be an exception since it is only ever used // in the above method?,,,unknown,yes,0
,"//init the table here instead of earlier, so that we can get a quoted table name //TODO: would it be better to simply pass the qualified table name, instead of //      splitting it up into schema/catalog/table names",,,unknown,yes,0
,//is this ok?,,,unknown,yes,0
,// create an index on the key columns??,,,unknown,yes,0
,"// TODO : make this the factory for ""entity mode related"" sessions; // also means making this the target of transaction-synch and the // thing that knows how to cascade things between related sessions // // At that point, perhaps this thing is a ""SessionContext"", and // ConnectionManager is a ""JDBCContext""?  A ""SessionContext"" should // live in the impl package...",,,unknown,yes,0
,// TODO : this really needs to be delayed unitl after we definitively know all node types // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected type,,,unknown,yes,0
,"// otherwise, a trim-specification and/or a trim-character // have been specified;  we need to decide which options // are present and ""do the right thing"" // should leading trim-characters be trimmed? // should trailing trim-characters be trimmed? // the trim-character // the trim-source",,,unknown,yes,0
,"//it is possible that the tree-walking in OuterJoinLoader can get to //an association defined by a subclass, in which case the property-ref //might refer to a property defined on a subclass of the current class //in this case, the table name is not known - this temporary solution  //assumes that the property-ref refers to a property of the subclass //table that the association belongs to (a reasonable guess) //TODO: fix this, add: OuterJoinLoadable.getSubclassPropertyTableName(String propertyName)",,,unknown,yes,0
,// TODO: an alternative is to check if the owner has changed; if it hasn't then // return collection.getOwner(),,,unknown,yes,0
,"// TODO : not sure this is correct, could not find docs on how to do this.",,,unknown,yes,0
,//TODO: move to .sql package!!,,,unknown,yes,0
,"// TODO: It would be really, really nice to use this to also model components!",,,unknown,yes,0
,// Sets can be just a view of a part of another collection. // do we need to copy it to be sure it won't be changing // underneath us? // ie. this.set.addAll(set);,,,unknown,yes,0
,// todo : move to StringHelper?,,,unknown,yes,0
,//TODO: should orphans really be deleted during lock???,,,unknown,yes,0
,// yick!  need this for proper serialization/deserialization handling...,,,unknown,yes,0
,// merges don't cascade to uninitialized collections //			//TODO: perhaps this does need to cascade after all....,,,unknown,yes,0
,//HSQL has no Blob/Clob support .... but just put these here for now!,,,unknown,yes,0
,// todo : is there really any reason to kkeep trying if this fails once?,,,unknown,yes,0
,//I suppose?,,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,//TODO: simply remove this override //      if we fix the above todos,,,unknown,yes,0
,// todo : should we additionally check the current isolation mode explicitly?,,,unknown,yes,0
,"// TODO : probably better to calculate these and pass them in, as it'll be more performant",,,unknown,yes,0
,//TODO: we should provide some way to get keys of collection of statistics to make it easier to retrieve from a GUI perspective,,,unknown,yes,0
,//shortcut,,,unknown,yes,0
,//TODO: used to be exprNoParens! was this needed?,,,unknown,yes,0
,// really there are two situations where it should be ok to allow the insertion // into properties defined on a superclass: //      1) union-subclass with an abstract root entity //      2) discrim-subclass // // #1 is handled already because of the fact that // UnionSubclassPersister alreay always returns 0 // for this call... // // we may want to disallow it for discrim-subclass just for // consistency-sake (currently does not work anyway)...,,,unknown,yes,0
,// todo : what is the implication of this?,,,unknown,yes,0
,// this is done here 'cos we might only know the type here (ugly!) // TODO: improve this a lot:,,,unknown,yes,0
,// Does this dialect support the UNIQUE column syntax?,,,unknown,yes,0
,// this is called by SessionFactory irregardless; we just disregard here; // could also add a check to SessionFactory to only conditionally call start,,,unknown,yes,0
,// Does this dialect support check constraints?,,,unknown,yes,0
,"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */",,,unknown,yes,0
,// Do we need to drop constraints before dropping tables in this dialect?,,,unknown,yes,0
,// todo: this was added to support initializing an entity's EntityEntry snapshot during reattach; // this should be refactored to instead expose a method to assemble a EntityEntry based on this // state for return.,,,unknown,yes,0
,//note there is a wierd implementation in the client side,,,unknown,yes,0
,"// turn hibernate.c3p0.* into c3p0.*, so c3p0 // gets a chance to see all hibernate.c3p0.*",,,unknown,yes,0
,"//TODO: to handle concurrent writes correctly, the client should pass in a Lock",,,unknown,yes,0
,// todo : what else to do here?,,,unknown,yes,0
,//TODO: disable batch loading if lockMode > READ?,,,unknown,yes,0
,// todo : what else to do here?,,,unknown,yes,0
,//perhaps not really necessary...,,,unknown,yes,0
,"// use COUNT as the default.  This mimics the old behavior, although // NONE might be a better option moving forward in the case of callable",,,unknown,yes,0
,// note: at least my local MySQL 5.1 install shows this not working...,,,unknown,yes,0
,// note: at least my local SQL Server 2005 Express shows this not working...,,,unknown,yes,0
,"// RDMS does not directly support the trim() function, we use rtrim() and ltrim()",,,unknown,yes,0
,// this call is side-effecty,,,unknown,yes,0
,// Does this dialect support the FOR UPDATE syntax?,,,unknown,yes,0
,// todo : YUCK!!!,,,unknown,yes,0
,//create an index on the key columns??,,,unknown,yes,0
,"// todo : again, how *should* this work for non-pojo entities?",,,unknown,yes,0
,// TODO : not so sure this is needed...,,,unknown,yes,0
,//TODO: redesign how PropertyAccessors are acquired...,,,unknown,yes,0
,"//TODO: this is too conservative; if all preceding joins were  //      also inner joins, we could use an inner join here",,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,//FIXME: get the PersistentClass,,,unknown,yes,0
,//TODO: inefficient,,,unknown,yes,0
,// TODO: what type?,,,unknown,yes,0
,// TODO: this is a bit of copy/paste from IndexedCollection.createPrimaryKey(),,,unknown,yes,0
,//TODO: merge into one method!,,,unknown,yes,0
,// This inner class implements a case statement....perhaps im being a bit over-clever here,,,unknown,yes,0
,//TODO: Somehow add the newly created foreign keys to the internal collection,,,unknown,yes,0
,// we have to set up the table later!! yuck,,,unknown,yes,0
,//Icky workaround for MySQL bug:,,,unknown,yes,0
,"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */",,,unknown,yes,0
,// Does this dialect support the Oracle-style FOR UPDATE NOWAIT syntax?,,,unknown,yes,0
,"//TODO: better to degrade to lazy=""false"" if uninstrumented",,,unknown,yes,0
,"//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here? //TODO: is it kosher to do it here?",,,unknown,yes,0
,"//TODO: really bad, evil hack to fix!!!",,,unknown,yes,0
,"// Does this dialect support FOR UPDATE OF, allowing particular rows to be locked?",,,unknown,yes,0
,//TODO: BUG! this currently fails for named queries for non-POJO entities,,,unknown,yes,0
,"//Don't need this, because we should never ever be selecting no columns in an insert ... select... //and because it causes a bug on DB2",,,unknown,yes,0
,// TODO: cannot use generateSuffixes() - it handles the initial suffix differently.,,,unknown,yes,0
,"// TODO : not sure which (either?) is correct, could not find docs on how to do this. // did find various blogs and forums mentioning that select CURRENT_TIMESTAMP // does not work...",,,unknown,yes,0
,//TODO: currently we don't know a SessionFactory reference when building the Tuplizer //      THIS IS A BUG (embedded-xml=false on component) // TODO : fix this after HHH-1907 is complete,,,unknown,yes,0
,"// TODO: at the point where we are resolving collection references, we don't // know if the uk value has been resolved (depends if it was earlier or // later in the mapping document) - now, we could try and use e.getStatus() // to decide to semiResolve(), trouble is that initializeEntity() reuses // the same array for resolved and hydrated values",,,unknown,yes,0
,// TODO: this disables laziness even in non-pojo entity modes:,,,unknown,yes,0
,//TODO: old version did not require hashmap lookup: //keys[collectionOwner].getIdentifier(),,,unknown,yes,0
,"//TODO: entities CAN be compared, by PK, fix this! -> only if/when we can extract the id values....",,,unknown,yes,0
,"// For a one-to-many, a <bag> is not really a bag; // it is *really* a set, since it can't contain the // same element twice. It could be considered a bug // in the mapping dtd that <bag> allows <one-to-many>.",,,unknown,yes,0
,//TODO: this is kinda inconsistent with CollectionType,,,unknown,yes,0
,"//TODO: not really completely correct, since //      the uoe could occur while resolving //      associations, leaving the PC in an //      inconsistent state",,,unknown,yes,0
,"//TODO: would be nice to use false, but issues with MS SQL",,,unknown,yes,0
,"// TODO: Deal with the ""optional"" attribute in the <join> mapping; // this code assumes that optional defaults to ""true"" because it // doesn't actually seem to work in the fetch=""join"" code // // Note that actual proper handling of optional-ality here is actually // more involved than this patch assumes.  Remember that we might have // multiple <join/> mappings associated with a single entity.  Really // a couple of things need to happen to properly handle optional here: //  1) First and foremost, when handling multiple <join/>s, we really //      should be using the entity root table as the driving table; //      another option here would be to choose some non-optional joined //      table to use as the driving table.  In all likelihood, just using //      the root table is much simplier //  2) Need to add the FK columns corresponding to each joined table //      to the generated select list; these would then be used when //      iterating the result set to determine whether all non-optional //      data is present // My initial thoughts on the best way to deal with this would be // to introduce a new SequentialSelect abstraction that actually gets // generated in the persisters (ok, SingleTable...) and utilized here. // It would encapsulated all this required optional-ality checking...",,,unknown,yes,0
,// TODO: does not work for EntityMode.DOM4J yet!,,,unknown,yes,0
,"//TODO: entities CAN be compared, by PK and entity name, fix this!",,,unknown,yes,0
,//TODO: currently broken for unique-key references (does not detect //      change to unique key property of the associated object),,,unknown,yes,0
,//TODO: currently broken for unique-key references (does not detect //      change to unique key property of the associated object) //the owner of the association is not the owner of the id,,,unknown,yes,0
,"// could happen for custom Criteria impls.  Not likely, but... // 		for long term solution, see HHH-3514",,,unknown,yes,0
,"//TODO: when this is the entry point, we should use an INNER_JOIN for fetching the many-to-many elements!",,,unknown,yes,0
,"// This does not support the Cache SQL 'DISTINCT BY (comma-list)' extensions, // but this extension is not supported through Hibernate anyway.",,,unknown,yes,0
,"//TODO: This is assertion is disabled because there is a bug that means the //	  original owner of a transient, uninitialized collection is not known //	  if the collection is re-referenced by a different object associated //	  with the current Session //throw new AssertionFailure(""bug loading unowned collection"");",,,unknown,yes,0
,// note that this timestamp is not correct if the connection provider // returns an older JDBC connection that was associated with a // transaction that was already begun before openSession() was called // (don't know any possible solution to this!),,,unknown,yes,0
,//TODO: this requires that the collection is defined after the //      referenced property in the mapping file (ok?),,,unknown,yes,0
,// TODO : currently we really do not handle ValueInclusion.PARTIAL... // ValueInclusion.PARTIAL would indicate parts of a component need to // be included in the select; currently we then just render the entire // component into the select clause in that case.,,,unknown,yes,0
,//TODO: is this completely correct?,,,unknown,yes,0
,// TODO : this is broke for subqueries in statements other than selects...,,,unknown,yes,0
,"//TODO: would be nice to use false, but issues with MS SQL",,,unknown,yes,0
,"//TODO: inexact, what we really need to know is: are any outer joins used?",,,unknown,yes,0
,"//TODO: would be nice to use false, but issues with MS SQL",,,unknown,yes,0
,"// The preference here would be //   SQLFunctionTemplate( Hibernate.TIMESTAMP, ""current_timestamp(?1)"", false) // but this appears not to work. // Jay Nance 2006-09-22",,,unknown,yes,0
,// TODO: figure out how this should be set. /////////////////////////////////////////////////////////////////////////////// // This was the reason for failures regarding INDEX_OP and subclass joins on // theta-join dialects; not sure what behaviour we were trying to emulate ;) //		joinSequence = joinSequence.getFromPart();	// Emulate the old addFromOnly behavior.,,,unknown,yes,0
,"// three general cases we check here as to whether to render a physical SQL join: // 1) is our parent a DotNode as well?  If so, our property reference is // 		being further de-referenced... // 2) is this a DML statement // 3) we were asked to generate any needed joins (generateJoins==true) *OR* //		we are currently processing a select or from clause // (an additional check is the REGRESSION_STYLE_JOIN_SUPPRESSION check solely intended for the test suite) // // The REGRESSION_STYLE_JOIN_SUPPRESSION is an additional check // intended solely for use within the test suite.  This forces the // implicit join resolution to behave more like the classic parser. // The underlying issue is that classic translator is simply wrong // about its decisions on whether or not to render an implicit join // into a physical SQL join in a lot of cases.  The piece it generally // tends to miss is that INNER joins effect the results by further // restricting the data set!  A particular manifestation of this is // the fact that the classic translator will skip the physical join // for ToOne implicit joins *if the query is shallow*; the result // being that Query.list() and Query.iterate() could return // different number of results!",,,unknown,yes,0
,// TODO : should this be an error?,,,unknown,yes,0
,"/*         * The following types are not supported in RDMS/JDBC and therefore commented out.         * However, in some cases, mapping them to CHARACTER columns works         * for many applications, but does not work for all cases.         */",,,unknown,yes,0
,"//no need to take a snapshot - this is a  //performance optimization, but not really //important, except for entities with huge  //mutable property values",,,unknown,yes,0
,// TODO: what if batchUpdate is a callablestatement ? // calls executeBatch(),,,unknown,yes,0
,//note that this implementation is kinda broken //for components with many-to-one associations,,,unknown,yes,0
,// todo : this call will not work for anything other than pojos!,,,unknown,yes,0
,"// assume that the row was not there since it previously had only null // values, so do an INSERT instead //TODO: does not respect dynamic-insert",,,unknown,yes,0
,"/*		  * Algorithm		  * Check for any level one nullability breaks		  * Look at non null components to		  *   recursively check next level of nullability breaks		  * Look at Collections contraining component to		  *   recursively check next level of nullability breaks		  *		  *		  * In the previous implementation, not-null stuffs where checked		  * filtering by level one only updateable		  * or insertable columns. So setting a sub component as update=""false""		  * has no effect on not-null check if the main component had good checkeability		  * In this implementation, we keep this feature.		  * However, I never see any documentation mentioning that, but it's for		  * sure a limitation.		  */",,,unknown,yes,0
,// TODO : this really needs to be delayed unitl after we definitively know the operand node type; // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected type,,,unknown,yes,0
,"//TODO: passing null here, because this method is not really used for DOM4J at the moment //      but it is still a bug, if we don't get rid of this!",,,unknown,yes,0
,"// First, validate all the enabled filters... //TODO: this implementation has bad performance",,,unknown,yes,0
,// This doesn't actually seem to work but it *might* // work on some dbs. Also it doesn't work if there // are multiple columns of results because it // is not accounting for the suffix: // return new String[] { getDiscriminatorColumnName() };,,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,"/* TODO: joinKeyColumnName & foreignKeyColumnName should be called either here or at a			 * slightly higer level in the stack (to get all the information we need)			 * Right now HbmBinder does not support the			 */",,,unknown,yes,0
,//TODO: switch statements are always evil! We already had bugs because  //      of forgotten token types. Use polymorphism for this!,,,unknown,yes,0
,//PostLoad is needed for EJB3 //TODO: reuse the PostLoadEvent...,,,unknown,yes,0
,"// todo : hack!!! // NOTE : here we cleanup the load context when we have no more local // LCE entries.  This ""works"" for the time being because really // only the collection load contexts are implemented.  Long term, // this cleanup should become part of the ""close result set"" // processing from the (sandbox/jdbc) jdbc-container code.",,,unknown,yes,0
,"// todo : i'd much rather have this done from #endLoadingCollection(CollectionPersister,LoadingCollectionEntry)...",,,unknown,yes,0
,// this only works because collection entries are kept in a sequenced // map by persistence context (maybe we should do like entities and // keep a separate sequences set...) //TODO: calling entrySet on an IdentityMap is SLOW!!,,,unknown,yes,0
,//TODO: not quite sure about the full implications of this!,,,unknown,yes,0
,//TODO: ugly here:,,,unknown,yes,0
,"/**	 * This form used from annotations (?).  Essentially the same as the above using a	 * resultset-mapping reference, but without cacheMode, readOnly, and comment.	 *	 * FIXME: annotations do not use it, so it can be remove from my POV	 * @deprecated	 *	 *	 * @param query The sql query string	 * @param resultSetRef The result-set-mapping name	 * @param querySpaces Any specified query spaces (used for auto-flushing)	 * @param cacheable Whether the query results are cacheable	 * @param cacheRegion If cacheable, the region into which to store the results	 * @param timeout A JDBC-level timeout to be applied	 * @param fetchSize A JDBC-level fetch-size to be applied	 * @param flushMode The flush mode to use for this query	 * @param parameterTypes parameter type map	 * @param callable Does the query string represent a callable object (i.e., proc)	 */",,,unknown,yes,0
,//TODO: would it be better to do a refresh from db?,,,unknown,yes,0
,//do we even really need this? the update will fail anyway....,,,unknown,yes,0
,//TODO: better to pass the id in as an argument?,,,unknown,yes,0
,"// todo : need map? the prob is a proper key, right?",,,unknown,yes,0
,//TODO: Should this be an InitializeEntityEventListener??? (watch out for performance!),,,unknown,yes,0
,// this class has no proxies (so do a shortcut),,,unknown,yes,0
,"//TODO: this bit actually has to be called after all cascades! //      but since identity insert is called *synchronously*, //      instead of asynchronously as other actions, it isn't",,,unknown,yes,0
,// todo : we can actually just determine this from the incoming EntityEntry-s,,,unknown,yes,0
,//TODO: suck this logic into the collection!,,,unknown,yes,0
,// orphans should not be deleted during merge??,,,unknown,yes,0
,// orphans should not be deleted during copy??,,,unknown,yes,0
,//TODO: reenable if we also fix the above todo,,,unknown,yes,0
,"// This next bit is to allow for both unsaved-value=""negative"" // and for ""older"" behavior where version number did not get // seeded if it was already set in the object // TODO: shift it into unsaved-value strategy",,,unknown,yes,0
,// todo : add the notion of enabled filters to the CacheKey to differentiate filtered collections from non-filtered; //      but CacheKey is currently used for both collections and entities; would ideally need to define two seperate ones; //      currently this works in conjuction with the check on //      DefaultInitializeCollectionEventHandler.initializeCollectionFromCache() (which makes sure to not read from //      cache with enabled filters). // EARLY EXIT!!!!!,,,unknown,yes,0
,// todo : should we check the current isolation mode explicitly?,,,unknown,yes,0
,//TODO: improve this hack!,,,unknown,yes,0
,// brand new collection //TODO: or an array!! we can't lock objects with arrays now??,,,unknown,yes,0
,"// TODO : an optimization here would be to consider cascade deletes and not gen those delete statements; //      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters -> //          the table info gotten here should really be self-contained (i.e., a class representation //          defining all the needed attributes), then we could then get an array of those",,,unknown,yes,0
,"// TODO : we really need to be able to deal with component paths here also; // this is difficult because the hql-sql grammar expects all those node types // to be FromReferenceNodes.  One potential fix here would be to convert the // IntoClause to just use a FromClause/FromElement combo (as a child of the // InsertStatement) and move all this logic into the InsertStatement.  That's // probably the easiest approach (read: least amount of changes to the grammar // and code), but just doesn't feel right as then an insert would contain // 2 from-clauses",,,unknown,yes,0
,"// VERY IMPORTANT!!!! - This class needs to be free of any static references // to any CGLIB or Javassist classes.  Otherwise, users will always need both // on their classpaths no matter which (if either) they use. // // Another option here would be to remove the Hibernate.isPropertyInitialized() // method and have the users go through the SessionFactory to get this information.",,,unknown,yes,0
,// TODO : remove these last two as batcher is no longer managing connections,,,unknown,yes,0
,"// even here, if only properties mapped to the ""base table"" are referenced // in the set and where clauses, this could be handled by the BasicDelegate. // TODO : decide if it is better performance-wise to perform that check, or to simply use the MultiTableUpdateDelegate",,,unknown,yes,0
,//TODO: is this a bit ugly?,,,unknown,yes,0
,// TODO : absolutely no usages of this constructor form; can it go away?,,,unknown,yes,0
,//TODO:this is only needed during compilation .. can we eliminate the instvar?,,,unknown,yes,0
,"// at some point the generate phase needs to be moved out of here, // because a single object-level DML might spawn multiple SQL DML // command executions. // // Possible to just move the sql generation for dml stuff, but for // consistency-sake probably best to just move responsiblity for // the generation phase completely into the delegates // (QueryLoader/StatementExecutor) themselves.  Also, not sure why // QueryLoader currently even has a dependency on this at all; does // it need it?  Ideally like to see the walker itself given to the delegates directly...",,,unknown,yes,0
,"// this function has a template -> restore output, apply the template and write the result out // TODO: Downcast to avoid using an interface?  Yuck.",,,unknown,yes,0
,// Not possible to simply re-use the versionPropertyNode here as it causes // OOM errors due to circularity :(,,,unknown,yes,0
,"/////////////////////////////////////////////////////////////////////// // HACK ALERT !!!!!!!!!!!!!!!!!!!!!!!!!!!! // Attempt to work around ""ghost"" ImpliedFromElements that occasionally // show up between the actual things being joined.  This consistently // occurs from index nodes (at least against many-to-many).  Not sure // if there are other conditions // // Essentially, look-ahead to the next FromElement that actually // writes something to the SQL",,,unknown,yes,0
,// TODO : better way?!?,,,unknown,yes,0
,"// No explicit select expression; render the id and properties // projection lists for every persister in the from clause into // a single 'token node'. //TODO: the only reason we need this stuff now is collection filters, //      we should get rid of derived select clause completely!",,,unknown,yes,0
,"// todo : currently expects that the individual with expressions apply to the same sql table join. //      This may not be the case for joined-subclass where the property values //      might be coming from different tables in the joined hierarchy.  At some //      point we should expand this to support that capability.  However, that has //      some difficulties: //          1) the biggest is how to handle ORs when the individual comparisons are //              linked to different sql joins. //          2) here we would need to track each comparison individually, along with //              the join alias to which it applies and then pass that information //              back to the FromElement so it can pass it along to the JoinSequence",,,unknown,yes,0
,// TODO : most of below was taken verbatim from DotNode; should either delegate this logic or super-type it,,,unknown,yes,0
,"/** * Provides query splitting methods, which were originally in QueryTranslator. * <br> * TODO: This will need to be refactored at some point. * * @author josh */",,,unknown,yes,0
,// TODO : perhaps we should additionally require that the incoming entity // version be equivalent to the defined unsaved-value?,,,unknown,yes,0
,"// TODO: iteratively get transient entities and retry merge until one of the following conditions: //       1) transientCopyCache.size() == 0 //       2) transientCopyCache.size() is not decreasing and copyCache.size() is not increasing // TODO: find out if retrying can add entities to copyCache (don't think it can...) // For now, just retry once; throw TransientObjectException if there are still any transient entities",,,unknown,yes,0
,// Does this dialect support the ALTER TABLE syntax?,,,unknown,yes,0
,"//for arrays, we should end the collection load before resolving //the entities, since the actual array instances are not instantiated //during loading //TODO: or we could do this polymorphically, and have two //      different operations implemented differently for arrays",,,unknown,yes,0
,// is it necessary to register %exact since it can only appear in a where clause?,,,unknown,yes,0
,"// sql-server, at least needed this dropped after use; strange!",,,unknown,yes,0
,"//just to help out during the load (ugly, i know)",,,unknown,yes,0
,// todo : remove,,,unknown,yes,0
,// todo : this eventually needs to be removed,,,unknown,yes,0
,"//workaround, for backward compatibility of sets with no //not-null columns, assume all columns are used in the //row locator SQL",,,unknown,yes,0
,//TODO: copy/paste from recreate(),,,unknown,yes,0
,//use of a stringbuffer to workaround a JDK bug,,,unknown,yes,0
,//ie. the subquery! yuck!,,,unknown,yes,0
,//TODO: is this right??,,,unknown,yes,0
,"// 'hibernate.temp.use_jdbc_metadata_defaults' is a temporary magic value. // The need for it is intended to be alleviated with future developement, thus it is // not defined as an Environment constant... // // it is used to control whether we should consult the JDBC metadata to determine // certain Settings default values; it is useful to *not* do this when the database // may not be available (mainly in tools usage).",,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,//TODO: suck this into initLaziness!,,,unknown,yes,0
,"//TODO: should this be Session.instantiate(Persister, ...)?",,,unknown,yes,0
,"// TODO: this is very suboptimal for some subclasses (namely components), // since it does not take advantage of two-phase-load",,,unknown,yes,0
,// todo : we can remove this once the deprecated ctor can be made private...,,,unknown,yes,0
,//ick!,,,unknown,yes,0
,// can happen because of the multiple ways Cache.remove() // can be invoked :(,,,unknown,yes,0
,"//TODO: ideally we need the construction of PropertyAccessor to take the following: //      1) EntityMode //      2) EntityMode-specific data (i.e., the classname for pojo entities) //      3) Property-specific data based on the EntityMode (i.e., property-name or dom4j-node-name) // The easiest way, with the introduction of the new runtime-metamodel classes, would be the // the following predicates: //      1) PropertyAccessorFactory.getPropertyAccessor() takes references to both a //          org.hibernate.metadata.EntityModeMetadata and org.hibernate.metadata.Property //      2) What is now termed a ""PropertyAccessor"" stores any values needed from those two //          pieces of information //      3) Code can then simply call PropertyAccess.getGetter() with no parameters; likewise with //          PropertyAccessor.getSetter()",,,unknown,yes,0
,//use of trim() here is ugly?,,,unknown,yes,0
,"//TODO: bad implementation, cos it depends upon ordering of mapping doc //      fixing this requires that Collection/PersistentClass gain access //      to the Mappings reference from Configuration (or the filterDefinitions //      map directly) sometime during Configuration.buildSessionFactory //      (after all the types/filter-defs are known and before building //      persisters).",,,unknown,yes,0
,// hack/workaround as sqlquery impl depend on having a key.,,,unknown,yes,0
,//TODO: handle the case of a foreign key to something other than the pk,,,unknown,yes,0
,//TODO: assumes all collections disassemble to an array!,,,unknown,yes,0
,//TODO: this dependency is kinda Bad,,,unknown,yes,0
,// todo : remove this and just have subclasses use Isolater/IsolatedWork directly...,,,unknown,yes,0
,"//for sets, we should end the collection load after resolving //the entities, since we might call hashCode() on the elements //TODO: or we could do this polymorphically, and have two //      different operations implemented differently for arrays",,,unknown,yes,0
,"// does this need holdlock also? : return tableName + "" with (updlock, rowlock, holdlock)"";",,,unknown,yes,0
,"//TODO: can we *always* use the ""null property"" approach for everything?",,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,"// important, to account for newly saved entities in query // todo : some kind of check for new status...",,,unknown,yes,0
,// why does this matter?,,,unknown,yes,0
,//TODO: get SQL rendering out of this package!,,,unknown,yes,0
,"// TODO: should ""record"" how many properties we have reffered to - and if we  //       don't get'em'all we throw an exception! Way better than trial and error ;)",,,unknown,yes,0
,// todo : would love to have this work on a notification basis //    where the successful binding of an entity/subclass would //    emit a notification which the extendsQueue entries could //    react to...,,,unknown,yes,0
,// get the right object from the list ... would it be easier to just call getEntity() ??,,,unknown,yes,0
,// todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification // see the discussion there in DynamicFilterParameterSpecification's javadocs as to why // it is currently not done that way.,,,unknown,yes,0
,//TODO: this is temporary in that the end result will probably not take a Property reference per-se.,,,unknown,yes,0
,//use a degenerated strategy for backward compatibility,,,unknown,yes,0
,"// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)",,,unknown,yes,0
,//TODO possibly relax that,,,unknown,yes,0
,"//TODO: deprecated, remove eventually",,,unknown,yes,0
,// TODO: is it really neceassry to provide Configuration to CollectionPersisters ? Should it not be enough with associated class ? // or why does EntityPersister's not get access to configuration ? // // The only reason I could see that Configuration gets passed to collection persisters // is so that they can look up the dom4j node name of the entity element in case // no explicit node name was applied at the collection element level.  Are you kidding me? // Trivial to fix then.  Just store and expose the node name on the entity persister // (which the collection persister looks up anyway via other means...).,,,unknown,yes,0
,// FIXME Hacky workaround to JBCACHE-1202,,,unknown,yes,0
,//hum ... should we cascade anyway? throw an exception? fine like it is?,,,unknown,yes,0
,// todo: this might really even be moved into the cfg package and used as the basis for all things which are configurable.,,,unknown,yes,0
,//TODO: copy/paste from insertRows(),,,unknown,yes,0
,//TODO: add owner argument!!,,,unknown,yes,0
,// TODO : temporary initial step towards HHH-1907,,,unknown,yes,0
,//TODO: cache this in an instvar,,,unknown,yes,0
,// TODO: check if key contains the owner ID,,,unknown,yes,0
,// TODO: I don't really like this implementation; it would be better if // this was handled by searchForDirtyCollections(),,,unknown,yes,0
,"//TODO: eventually put this back in, once we think all is fixed //Object otherAlias = columnsUnique.put(qualifiedColumn, columnAlias);",,,unknown,yes,0
,//TODO: terrible implementation!,,,unknown,yes,0
,// TODO : still need to make CollectionPersisters EntityMode-aware,,,unknown,yes,0
,//TODO: create uk loaders for component properties,,,unknown,yes,0
,"//TODO: add referencedClass to disambiguate to FKs on the same //      columns, pointing to different tables",,,unknown,yes,0
,"//TODO: cache the persister, this shows up in yourkit",,,unknown,yes,0
,//TODO: use these in methods above,,,unknown,yes,0
,// TODO: better error message since we actually support composites if names are explicitly listed.,,,unknown,yes,0
,//TODO: formulas ?,,,unknown,yes,0
,//TODO: can we limit stored procedures ?!,,,unknown,yes,0
,//TODO: proxies!,,,unknown,yes,0
,// TODO: not visible to the user!,,,unknown,yes,0
,//TODO: check that entry.getIdentifier().equals(requestedId),,,unknown,yes,0
,"//TODO: arithmetic expressions, multiple new Foo(...)",,,unknown,yes,0
,// TODO: toLowerCase was not done before. Only used in Template.,,,unknown,yes,0
,// todo : remove this once ComponentMetamodel is complete and merged,,,unknown,yes,0
,"//TODO handle supportsNotNullUnique=false, but such a case does not exist in the wild so far",,,unknown,yes,0
,// TODO: better error message since we actually support composites if names are explicitly listed.,,,unknown,yes,0
,//TODO: return new Lock(ts);,,,unknown,yes,0
,// todo : add support for READ_WRITE ( + NONSTRICT_READ_WRITE ??? ),,,unknown,yes,0
,// table=null -> an association - fill // it in later //TODO fill in the mappings for table == null,,,unknown,yes,0
,// table=null -> an association // - fill it in later //TODO fill in the mappings for table == null,,,unknown,yes,0
,//TODO check there is no actual definition elemnents when a ref is defined,,,unknown,yes,0
,"//TODO: if we are using identity columns, fetch the identifier",,,unknown,yes,0
,"/**	 * TODO: Check if Mimer SQL cannot handle the way DB2 does	 */",,,unknown,yes,0
,// todo : cache this sql...,,,unknown,yes,0
,// todo : look at optimizing these...,,,unknown,yes,0
,//TODO: theoretically non-threadsafe...,,,unknown,yes,0
,//TODO: avoid this for non-new instances where mightBeDirty==false,,,unknown,yes,0
,/////////////////////////////////////////////////////////////////////// // TODO : look at perhaps caching this...,,,unknown,yes,0
,// TODO : or should we return 'containsTableAlias'??,,,unknown,yes,0
,"// if we are still not resolved, we might represent a constant. //      needed to add this here because the allowance of //      naked-prop-refs in the grammar collides with the //      definition of literals/constants (""nondeterminism""). //      TODO: cleanup the grammar so that ""processConstants"" is always just handled from here",,,unknown,yes,0
,//TODO: include the rowids!!!!,,,unknown,yes,0
,//TODO: make this handle multiple collection roles!,,,unknown,yes,0
,//TODO: maybe call it getRowSelection() ?,,,unknown,yes,0
,//TODO: unnecessary for databases with ANSI-style joins,,,unknown,yes,0
,//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings,,,unknown,yes,0
,"//TODO: optimize away this lookup for entities w/o unsaved-value=""undefined""",,,unknown,yes,0
,"// TODO: lowercasing done here. Was done ""at random"" before; maybe not needed at all ?",,,unknown,yes,0
,"//TODO: assertion only, could be optimized away",,,unknown,yes,0
,// TODO: RESTRICT VIOLATION,,,unknown,yes,0
,"// work around the ""feature"" where tree cache is validating the // inserted node during the next transaction. no idea...",,,unknown,yes,0
,// FIXME hack to work around fact that calling // Node added = root.addChild( fqn ); doesn't  // properly set the version on the node,,,unknown,yes,0
,"// TODO : safe to interpret ""map.remove(key) == null"" as non-dirty?",,,unknown,yes,0
,// unhappy about this being public ... is there a better way?,,,unknown,yes,0
,//need to do that here rather than in the save event listener to let //the post insert events to have a id-filled entity when IDENTITY is used (EJB3),,,unknown,yes,0
,// can happen because of the multiple ways Cache.remove() // can be invoked :(,,,unknown,yes,0
,"// TODO: I considered validating TS cache config here, // but decided to defer unti getTimestampsCacheInstance() in case the  // cache is never actually used",,,unknown,yes,0
,"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */",,,unknown,yes,0
,"// work around the ""feature"" where tree cache is validating the // inserted node during the next transaction.  no idea...",,,unknown,yes,0
,"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */",,,unknown,yes,0
,"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */",,,unknown,yes,0
,// todo : eventually merge this with TreeCache and just add optional opt-lock support there.,,,unknown,yes,0
,// TODO Why not use the timestamp in a DataVersion?,,,unknown,yes,0
,"// TODO: I considered validating the presence of the TS cache here, // but decided to defer unti getQueryCacheInstance() in case the  // cache is never actually used",,,unknown,yes,0
,// TODO Is this a valid operation on a timestamps cache?,,,unknown,yes,0
,// xmlforest requires a new kind of function constructor,,,unknown,yes,0
,"// This, is used by SessionFactoryImpl to hand to the generated SessionImpl; // was the only reason I could see that we cannot just use null as // Settings.cacheProvider",,,unknown,yes,0
,"//TODO: never reached, since getTypeName() actually throws an exception!",,,unknown,yes,0
,//TODO: suck into event class,,,unknown,yes,0
,// TODO Is this a valid operation on a timestamps cache?,,,unknown,yes,0
,// todo : what else to do here?,,,unknown,yes,0
,// TODO: Replace this with a more elegant solution.,,,unknown,yes,0
,//TODO find a decent name before documenting,,,unknown,yes,0
,//TODO: check that entry.getIdentifier().equals(requestedId),,,unknown,yes,0
,"//TODO: get all properties, not just the fetched ones!",,,unknown,yes,0
,//TODO: validate existing of property with the chosen name. (secondpass ),,,unknown,yes,0
,//TODO: handle property-ref,,,unknown,yes,0
,"// TODO: bindpropertyresults(alias, returnElem)",,,unknown,yes,0
,//TODO: native ids,,,unknown,yes,0
,"//TODO: get all properties, not just the fetched ones!",,,unknown,yes,0
,// TODO: handle TypeDefs,,,unknown,yes,0
,//polymorphism comment above,,,unknown,yes,0
,// short cut check...,,,unknown,yes,0
,// TODO: encapsulate the protected instance variables!,,,unknown,yes,0
,// todo : remove,,,unknown,yes,0
,// inheritance cycle detection (paranoid check),,,unknown,yes,0
,//yuck!,,,unknown,yes,0
,// TODO : will need reference to session factory to fully complete HHH-1907,,,unknown,yes,0
,"// this is ugly here, but needed because its a subquery",,,unknown,yes,0
,"//put() has nowait semantics, is this really appropriate? //note that it needs to be async replication, never local or sync",,,unknown,yes,0
,"//TODO: to handle concurrent writes correctly, this should return a Lock to the client",,,unknown,yes,0
,// todo : add support for READ_WRITE ( + NONSTRICT_READ_WRITE ??? ),,,unknown,yes,0
,// TODO : why aren't these the same?,,,unknown,yes,0
,//TODO: proxies!,,,unknown,yes,0
,//TODO: proxies!,,,unknown,yes,0
,"//TODO: always true for now, but not if we later decide to support elements() in the from clause",,,unknown,yes,0
,//TODO: if lock.getTimestamp().equals(ts),,,unknown,yes,0
,//TODO mappings.getLogicalTableName(ownerTable),,,unknown,yes,0
,"//TODO: if we support multiple fetch groups, we would need //      to clone the set of lazy properties!",,,unknown,yes,0
,"// this is only needed (afaict) for processing results from the query cache; // however, this cannot possibly work in the case of discovered types...",,,unknown,yes,0
,//now we might need to recalculate the dirtyProperties array,,,unknown,no,1572368614
,// NOTE : firstRow is zero-based,,,unknown,no,1572368610
,// NOTE : firstRow is zero-based,,,unknown,no,1572368609
,// this is only needed (afaict) for ResultTransformer processing...,,,unknown,no,1572368607
,"//property-refs for associations defined on a //component are not supported, so no need to slice",,,unknown,no,1572368604
,// hibernate type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,1572368600
,// create the collection holding the Orphans,,,unknown,no,1572368598
,//check for all components values in the collection,,,unknown,no,1572368596
,//treat it just like a new collection,,,unknown,no,1572368594
,"// A list of collection wrappers that were instantiating during result set // processing, that we will need to initialize at the end of the query",,,unknown,no,1572368591
,//figure out which tables need to be fetched,,,unknown,no,1572368578
,// Need to account for allowable '_' within the variant,,,unknown,no,1572368572
,"// for non-arrays, we don't need to know the element class //elementType.returnedClass();",,,unknown,no,1572368568
,"// for a subquery, the alias to use depends on a few things (we // already know this is not an overall SELECT): //      1) if this FROM_ELEMENT represents a correlation to the //          outer-most query //              A) if the outer query represents a multi-table //                  persister, we need to use the given alias //                  in anticipation of one of the multi-table //                  executors being used (as this subquery will //                  actually be used in the ""id select"" phase //                  of that multi-table executor) //              B) otherwise, we need to use the persister's //                  table name as the column qualification //      2) otherwise (not correlated), use the given alias",,,unknown,no,1572368566
,// Remove all the old entries,,,unknown,no,1572368539
,// get meta's from <hibernate-mapping>,,,unknown,no,1572368537
,// Begin unit of work,,,unknown,no,1572368535
,"// the MRU cache used to keep hard references to the most recently used query plans; // note : LRU here is a bit of a misnomer, it indicates that LRU entries are removed, the // actual kept entries are the MRU entries",,,unknown,no,1572368533
,"//if we could not register a synchronization, //do the before/after completion callbacks //ourself (but we need to let jdbcContext //know that this is what we are going to //do, so it doesn't keep trying to register //synchronizations)",,,unknown,no,1572364465
,"//not really necessary, but good for consistency...",,,unknown,no,1572364459
,//we never need to apply locks to the SQL,,,unknown,no,1572364456
,// note: interface is assumed to already contain HibernateProxy.class,,,unknown,no,1572364453
,// collection of <many-to-any/> mappings... // used to circumvent the component-collection check below...,,,unknown,no,1572364450
,"// otherwise, just dump it",,,unknown,no,1572364447
,//do nothing - we only need to notify the cache...,,,unknown,no,1572364444
,"// Note : success = false, because we don't know the outcome of the transaction",,,unknown,no,1572364440
,"// this one only really needed for badly-behaved applications! // (if the TransactionManager has a Sychronization registered, // its a noop) // (actually we do need it for downgrading locks)",,,unknown,no,1572364431
,// this is used during SqlGenerator processing,,,unknown,no,1572364422
,"// short-circuit(s) // no new elements, the old list contains only Orphans // no old elements, so no Orphans neither",,,unknown,no,1572364410
,"// all this only really needs to consider properties // of this class, not its subclasses, but since we // are reusing code used for sequential selects, we // use the subclass closure",,,unknown,no,1572364403
,// don't need to check laziness (dirty checking algorithm handles that),,,unknown,no,1572364393
,//needed by arrays,,,unknown,no,1572364391
,//allow index() function:,,,unknown,no,1572364389
,"//+ ""_"" + referencedColumnName not used for backward compatibility",,,unknown,no,1572364387
,"//+ ""_"" + referencedColumnName not used for backward compatibility",,,unknown,no,1572364378
,// orphans should be deleted during save/update,,,unknown,no,1572364375
,// special case where we need to force incloude all subclass joins,,,unknown,no,1572364372
,"// NOTE: we need to do the wrap here even if its not ""dirty"", // because collections need wrapping but changes to _them_ // don't dirty the container. Also, for versioned data, we // need to wrap before calling searchForDirtyCollections",,,unknown,no,1572364365
,//columns,,,unknown,no,1572364354
,//just a performance opt!,,,unknown,no,1572364345
,//only really need new array during semiresolve!,,,unknown,no,1572364338
,//just a performance opt!,,,unknown,no,1572364329
,// SQL Server (at least up through 2005) does not support defining // cascade delete constraints which can circel back to the mutating // table,,,unknown,no,1572364315
,"// NOTE : evict() operates locally only (i.e., does not propogate // to any other nodes in the potential cluster).  This is // exactly what is needed when we destroy() here; destroy() is used // as part of the process of shutting down a SessionFactory; thus // these removals should not be propogated",,,unknown,no,1572364297
,//figure out which columns are needed,,,unknown,no,1572364280
,"// VersionType impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //      Note : simply returns null for seed() and next() as the only known //      application of binary types for versioning is for use with the //      TIMESTAMP datatype supported by Sybase and SQL Server, which //      are completely db-generated values...",,,unknown,no,1572364276
,// orphans should be deleted during delete,,,unknown,no,1572364254
,"// otherwise, everything ok.",,,unknown,no,1572364240
,// need to extract the component values and check for subtype replacements...,,,unknown,no,1572364195
,"// We need our tm, so get it now and avoid doing other work // if there is a problem",,,unknown,no,1572364184
,"//we need to check even if it was not initialized, because of delayed adds!",,,unknown,no,1572364128
,"//if the collection is dereferenced, remove from the session cache //iter.remove(); //does not work, since the entrySet is not backed by the set",,,unknown,no,1572364125
,// We can't change the TM on a running cache; just check // if the cache has no TM and we're OK with that,,,unknown,no,1572364113
,// classic translator does not support collection of ordinal // param metadata,,,unknown,no,1572364079
,"// don't need subclass tables, because they can't appear in conditions",,,unknown,no,1572364069
,"//no need to check laziness, dirty checking handles that",,,unknown,no,1572364049
,"//this bit is only *really* absolutely necessary for handling //requestedId, but is also good if we merge multiple object //graphs, since it helps ensure uniqueness",,,unknown,no,1572364033
,//Sybase BIT type does not support null values,,,unknown,no,1572364024
,// do the work,,,unknown,no,1572364008
,// do the work,,,unknown,no,1572364007
,// Note this!!,,,unknown,no,1572363995
,"// NOTE : this is being used from the process of shutting down a // SessionFactory. Specific things to consider: // (1) this clearing of the region should not propagate to // other nodes on the cluster (if any); this is the // cache-mode-local option bit... // (2) really just trying a best effort to cleanup after // ourselves; lock failures, etc are not critical here; // this is the fail-silently option bit...",,,unknown,no,1572363984
,"// add an entry for this type of entity. // we can be assured that all referenced entities have already // been processed, // so specify that this entity is with the latest batch. // doing the batch number before adding the name to the list is // a faster way to get an accurate number.",,,unknown,no,1572363915
,// meant to handle dynamic instantiation queries...(Copy from QueryLoader),,,unknown,no,1572363878
,// otherwise:,,,unknown,no,0
,"// since this entity will now be processed in the latest possible batch, // we can be assured that it will come after all other associations, // there's not need to continue checking.",,,unknown,no,0
,// SUBCLASSES,,,unknown,no,0
,// break the outer loop !!!,,,unknown,no,0
,"// Fully resolve the map reference, create implicit joins.",,,unknown,no,0
,// callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// do nothing...,,,unknown,no,0
,"//if it is a property of an embedded component, invoke on the ""identifier""",,,unknown,no,0
,//overriden to avoid System.exit,,,unknown,no,0
,//select SQL,,,unknown,no,0
,// We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400,,,unknown,no,0
,// The keyword used to specify a nullable column.,,,unknown,no,0
,//insert/update/delete SQL,,,unknown,no,0
,// skip finalize methods,,,unknown,no,0
,// starts with the name of a mapped class (new style),,,unknown,no,0
,// The basic implementation is to simply use the node's text,,,unknown,no,0
,"// remove any snapshot, not really for memory management purposes, but // rather because it might now be stale, and there is no longer any  // EntityEntry to take precedence // This is now handled by removeEntity() //session.getPersistenceContext().removeDatabaseSnapshot(key);",,,unknown,no,0
,// interfaces // arguments,,,unknown,no,0
,"// InterSystems Cache' does not current support ""SELECT ... FOR UPDATE"" syntax... // Set your transaction mode to READ_COMMITTED before using",,,unknown,no,0
,//cascade to current collection elements,,,unknown,no,0
,// Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//QueryJoinFragment join = q.createJoinFragment(useThetaStyleJoin);,,,unknown,no,0
,// Try to find out the name of the primary key to create it as identity if the IdentityGenerator is used,,,unknown,no,0
,// we can't cascade to non-embedded elements,,,unknown,no,0
,//cant instantiate,,,unknown,no,0
,"// the ids are fully resolved, so compare them with isDirty(), not isModified()",,,unknown,no,0
,"//postDelete: // After actually deleting a row, record the fact that the instance no longer  // exists on the database (needed for identity-column key generation), and // remove it from the session cache",,,unknown,no,0
,//a newly instantiated collection can't have orphans,,,unknown,no,0
,"// Don't hold the JBC node lock throughout the tx, as that // prevents reads and other updates",,,unknown,no,0
,"// check the version unsaved-value, if appropriate",,,unknown,no,0
,"// Does the LIMIT clause take a ""maximum"" row number instead of a total number of returned rows?",,,unknown,no,0
,//now tie it all together,,,unknown,no,0
,"// return the (fully resolved) identifier value, but do not resolve // to the actual referenced entity instance // NOTE: the owner of the association is not really the owner of the id!",,,unknown,no,0
,"// both many-to-one and one-to-one are represented as a // Property.  EntityPersister is relying on this value to // determine ""lazy fetch groups"" in terms of field-level // interception.  So we need to make sure that we return // true here for the case of many-to-one and one-to-one // with lazy=""no-proxy"" // // * impl note - lazy=""no-proxy"" currently forces both // lazy and unwrap to be set to true.  The other case we // are extremely interested in here is that of lazy=""proxy"" // where lazy is set to true, but unwrap is set to false. // thus we use both here under the assumption that this // return is really only ever used during persister // construction to determine the lazy property/field fetch // groupings.  If that assertion changes then this check // needs to change as well.  Partially, this is an issue with // the overloading of the term ""lazy"" here...",,,unknown,no,0
,"//there is probably a row there, so try to update //if no rows were updated, we will find out",,,unknown,no,0
,// try to make sure we don't wrap and already wrapped session,,,unknown,no,0
,"// If this is an implied join in a FROM clause, then use ANSI-style joining, and set the // flag on the FromElement that indicates that it was implied in the FROM clause itself.",,,unknown,no,0
,//Not called at runtime so doesn't matter if its slow :),,,unknown,no,0
,//render the where and from parts,,,unknown,no,0
,// There is already an existing batch for this type of entity. // Check to see if the latest batch is acceptable.,,,unknown,no,0
,// allow these to go through the the real session no matter what,,,unknown,no,0
,// while constructor is running,,,unknown,no,0
,// Don't really know all the codes required to adequately decipher returned jdbc exceptions here. // simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail,,,unknown,no,0
,// The keyword used to specify a nullable column.,,,unknown,no,0
,//we *could* regerate this inside each called method!,,,unknown,no,0
,// while constructor is running,,,unknown,no,0
,//no point doing this if NONE was requested,,,unknown,no,0
,"// HHH-2481 make sure the callback gets cleared, otherwise the instance stays in a static thread local.",,,unknown,no,0
,// the CascadingAction implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// we need to obtain the lock before any actions are // executed, since this may be an inverse=""true"" // bidirectional association and it is one of the // earlier entity actions which actually updates // the database (this action is resposible for // second-level cache invalidation only)",,,unknown,no,0
,"/* This can never happen because this rule will always eliminate the child NOT.			case NOT:				return x.getFirstChild();			// (NOT (NOT x) ) => (x)*/",,,unknown,no,0
,//now render the joins,,,unknown,no,0
,"// if we know there is exactly 1 row, we can skip. // it would be great if we could _always_ skip this; // it is a problem for <key-many-to-one>",,,unknown,no,0
,"// If you're closing down the ConnectionProvider chances are an // is not a real big deal, just warn",,,unknown,no,0
,// create a new batch for this type. The batch number is the number of current batches.,,,unknown,no,0
,// keyword support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//note that each iteration of the loop may add new elements,,,unknown,no,0
,"//	public static JDBCException newJDBCException(String string, SQLException root, String sql) { //		string = string + "" ["" + sql + ']'; //		log.error(string, root); //		logExceptions(root); //		return new JDBCException(string, root, sql); //	} // //	public static JDBCException newJDBCException(String string, SQLException root) { //		log.error(string, root); //		logExceptions(root); //		return new JDBCException(string, root); //	}",,,unknown,no,0
,//do this work only at the very highest level of the load //don't let this method be called recursively,,,unknown,no,0
,// This will add the new from element to the origin.,,,unknown,no,0
,// the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this class,,,unknown,no,0
,//now render the select clause,,,unknown,no,0
,// The keyword used to insert a row without specifying // any column values,,,unknown,no,0
,// The property is a component...,,,unknown,no,0
,// Create the SessionFactory from hibernate.cfg.xml,,,unknown,no,0
,// Deserialize //-----------------------------------------------------------------------,,,unknown,no,0
,// the entity associated with the current action.,,,unknown,no,0
,//cannot occur,,,unknown,no,0
,//unwrap the object,,,unknown,no,0
,"// Identity map of array holder ArrayHolder instances, by the array instance",,,unknown,no,0
,// NativeSQL: collect key column and auto-aliases,,,unknown,no,0
,// Impl note: takes advantage of the fact that an escpaed single quote // embedded within a quote-block can really be handled as two seperate // quote-blocks for the purposes of this method...,,,unknown,no,0
,"// again, CCS did not have such a concept; but a reasonable // proximity is to clear the cache after transaction *as long as* // the underlying cache is not JTA aware.",,,unknown,no,0
,// this page intentionally left blank :),,,unknown,no,0
,// handle orphaned entities!!,,,unknown,no,0
,// Snapshots of current database state for entities // that have *not* been loaded,,,unknown,no,0
,"// unfortunately this stuff can't be cached because // it is per-invocation, not constant for the // QueryTranslator instance",,,unknown,no,0
,// delete does cascade to uninitialized collections,,,unknown,no,0
,"// Entity proxies, by EntityKey",,,unknown,no,0
,//initialize + unwrap the object,,,unknown,no,0
,// SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// Don't need to lock the cache here, since if someone // else inserted the same pk first, the insert would fail",,,unknown,no,0
,//cannot occur,,,unknown,no,0
,// This is not strictly true.  We actually just need to make sure that // it is ordered by root-entity PK and that that order-by comes before // any non-root-entity ordering...,,,unknown,no,0
,"// try ""get""",,,unknown,no,0
,// pass control along to the rest of the processing chain,,,unknown,no,0
,"// in case we were deserialized in a different JVM, look for an instance with the same name // (alternatively we could do an actual JNDI lookup here....)",,,unknown,no,0
,// Set of EntityKeys of deleted objects,,,unknown,no,0
,//optimize the hash size to eliminate a rehash.,,,unknown,no,0
,// should be safe to only ever expect EntityPersister references here,,,unknown,no,0
,//sort the updates by pk,,,unknown,no,0
,"/*protected void initPropertyPaths(			final String path,			final Type type,			final String[] columns,			final String[] formulaTemplates,			final Mapping factory)	throws MappingException {		//addFormulaPropertyPath(path, type, formulaTemplates);		initPropertyPaths(path, type, columns, formulaTemplates, factory);	}*/",,,unknown,no,0
,// Downgrade locks,,,unknown,no,0
,/*(array==null) ? tempList.size() :*/,,,unknown,no,0
,"//with two-deep subqueries, the same alias would get generated for //both using the old method (criteriaQuery.generateSQLAlias()), so //that is now used as a fallback if the main criteria alias isn't set",,,unknown,no,0
,//( (Column) model.getTable().getPrimaryKey().getColumnIterator().next() ).getName();,,,unknown,no,0
,//	public boolean isShowSqlEnabled() { //		return showSql; //	} // //	public boolean isFormatSqlEnabled() { //		return formatSql; //	},,,unknown,no,0
,// do nothing...,,,unknown,no,0
,// do not do anything,,,unknown,no,0
,// Write HTML footer,,,unknown,no,0
,"// Identity map of EntityEntry instances, by the entity instance",,,unknown,no,0
,// our column span is the number of columns in the PK,,,unknown,no,0
,// or should it actually throw an exception?,,,unknown,no,0
,// ignore,,,unknown,no,0
,"// Handles things like: // a and b or c // a and ( b or c ) // not a and not b // not ( a and b ) // x between y and z            (overloaded ""and"") // x in ( a, b, c )             (overloaded brackets) // not not a // a is not null                (overloaded ""not"") // etc...... // and expressions like // foo = bar                    (maps to: foo.id = bar.id) // foo.Bar = 'foo'              (maps to: foo.bar = 'foo') // foo.Bar.Baz = 1.0            (maps to: foo.bar = bar.id and bar.baz = 1.0) // 1.0 = foo.Bar.Baz            (maps to: bar.baz = 1.0 and foo.Bar = bar.id) // foo.Bar.Baz = a.B.C          (maps to: bar.Baz = b.C and foo.Bar = bar.id and a.B = b.id) // foo.Bar.Baz + a.B.C          (maps to: bar.Baz + b.C and foo.Bar = bar.id and a.B = b.id) // ( foo.Bar.Baz + 1.0 ) < 2.0  (maps to: ( bar.Baz + 1.0 ) < 2.0 and foo.Bar = bar.id)",,,unknown,no,0
,// check the id unsaved-value,,,unknown,no,0
,// early exit...,,,unknown,no,0
,"// if we get here, it is possible that we have a proxy 'in the way' of the merge map resolution... // 		NOTE: decided to put this here rather than in the above loop as I was nervous about the performance //		of the loop-in-loop especially considering this is far more likely the 'edge case'",,,unknown,no,0
,// check to see if it is in the second-level cache,,,unknown,no,0
,//Custom SQL (would be better if these were private),,,unknown,no,0
,///////////////////////////////////////////////////////////////////////,,,unknown,no,0
,//overwrite old proxy,,,unknown,no,0
,// we have the form: trim(trimSource) //      so we trim leading and trailing spaces // EARLY EXIT!!!!,,,unknown,no,0
,// ignore,,,unknown,no,0
,"// else no collection element, but also no owner",,,unknown,no,0
,//return the proxied object,,,unknown,no,0
,// For property references generate <tablealias>.<columnname> as <projectionalias>,,,unknown,no,0
,//do nothing to avoid a lazy property initialization,,,unknown,no,0
,"// unfortunately this stuff can't be cached because // it is per-invocation, not constant for the // QueryTranslator instance",,,unknown,no,0
,"// in case we were deserialized in a different JVM, look for an instance with the same name // (alternatively we could do an actual JNDI lookup here....)",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// KEY,,,unknown,no,0
,//force immediate execution of the insert,,,unknown,no,0
,// general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// entities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//,,,unknown,no,0
,"// Loaded entity instances, by EntityUniqueKey",,,unknown,no,0
,"// we can't batch joined inserts, *especially* not if it is an identity insert; // nor can we batch statements where the expectation is based on an output param",,,unknown,no,0
,//allow any identifier quoted with backtick //only recognizes identifiers beginning with a letter,,,unknown,no,0
,// collections ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);,,,unknown,no,0
,//insert all the new entries,,,unknown,no,0
,//	private boolean showSql; //	private boolean formatSql;,,,unknown,no,0
,// add normal properties,,,unknown,no,0
,// key is an entity involved with the operation performed by the listener; // value can be either a copy of the entity or the entity itself,,,unknown,no,0
,// no-op. We don't own the cache so we shouldn't stop it.,,,unknown,no,0
,// this piece is needed for usage in select clause,,,unknown,no,0
,"//noncritical, swallow and let the other propagate!",,,unknown,no,0
,"// if either its role changed,",,,unknown,no,0
,// handles arrays and newly instantiated collections,,,unknown,no,0
,// add the discriminator,,,unknown,no,0
,// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// the root of the incoming property path matched one // of the embedded composite identifier properties,,,unknown,no,0
,"//let's assume that there is only one lazy fetch group, for now!",,,unknown,no,0
,"// nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type here",,,unknown,no,0
,"// should be ok performance-wise to generate new delegate instances for each // request since these are locally stack-scoped.  Besides, it makes the code // much easier to read than the old TransactionHelper stuff...",,,unknown,no,0
,// it is or was referenced _somewhere_,,,unknown,no,0
,"// Mckoi has no known variation of a ""SELECT ... FOR UPDATE"" syntax...",,,unknown,no,0
,//	public ComponentTuplizerFactory getComponentTuplizerFactory() { //		return componentTuplizerFactory; //	},,,unknown,no,0
,// build an array with indices equal to the total number // of actual returns in the result Hibernate will return // for this query (scalars + non-scalars),,,unknown,no,0
,"// the owning entity may have been deleted and its identifier unset due to // identifier-rollback; in which case, try to look up its identifier from // the persistence context",,,unknown,no,0
,"// This check is needed since processing leaves the cursor // after the last physical row for the current logical row; // thus if we are after the last physical row, this might be // caused by either: //      1) scrolling to the last logical row //      2) scrolling past the last logical row // In the latter scenario, the previous logical row // really is the last logical row. // // In all other cases, we should process back two // logical records (the current logic row, plus the // previous logical row).",,,unknown,no,0
,// Get the names of the columns used to link between the collection // owner and the collection elements.,,,unknown,no,0
,"// more specifically : ""? [op] datetime"" //      1) if the operator is MINUS, the param needs to be of //          some datetime type //      2) if the operator is PLUS, the param needs to be of //          some numeric type",,,unknown,no,0
,// trying via forName() first to be as close to DriverManager's semantics,,,unknown,no,0
,"//		registerColumnType( Types.BLOB, 16777215, ""mediumblob"" ); //		registerColumnType( Types.BLOB, 65535, ""blob"" );",,,unknown,no,0
,"// can't just return null here, since that would // cause an owning component to become null",,,unknown,no,0
,// Turn off includeSubclasses on all FromElements.,,,unknown,no,0
,"//if an exception occurs during flush, user must call rollback()",,,unknown,no,0
,"// legacy behavior, apply the bridge...",,,unknown,no,0
,// kept for backward compatibility until after the 3.1beta5 release of HA,,,unknown,no,0
,//ie. e.status==DELETED,,,unknown,no,0
,"// properties of this class, including inherited properties",,,unknown,no,0
,// delegate already handles PK columns,,,unknown,no,0
,"// Impl Note: allows multiple collection fetches as long as the // entire fecthed graph still ""points back"" to a single // root entity for return",,,unknown,no,0
,// don't even bother trying to read any further,,,unknown,no,0
,"// note that for sequential scrolling, we make the assumption that // the first persister element is the ""root entity""",,,unknown,no,0
,// add the primary key,,,unknown,no,0
,// this property belongs on the table and is to be inserted,,,unknown,no,0
,// Base Expectation impls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// add the discriminator,,,unknown,no,0
,// static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// prepend value and type list with null for any positions before the wanted position.,,,unknown,no,0
,// add normal properties,,,unknown,no,0
,// drop them in reverse order in case db needs it done that way...,,,unknown,no,0
,"//fetch=""join"" overrides default laziness //fetch=""join"" overrides default laziness",,,unknown,no,0
,//	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907,,,unknown,no,0
,// select the correct row by either pk or rowid,,,unknown,no,0
,// transactions marked for rollback-only cause some TM impls to throw exceptions,,,unknown,no,0
,// This should only be possible if the caches are constructor injected ,,,unknown,no,0
,"//if the hibernate-mapping did not specify a schema/catalog, use the defaults //specified by properties - but note that if the schema/catalog were specified //in hibernate-mapping, or as params, they will already be initialized and //will override the values set here (they are in identifierGeneratorProperties)",,,unknown,no,0
,"// this is a property of the table, which we are updating",,,unknown,no,0
,"//not absolutely necessary, but helps for some //equals()/hashCode() implementations",,,unknown,no,0
,//lazy = !join;,,,unknown,no,0
,"//include the discriminator and class-level where, but not filters",,,unknown,no,0
,"//			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer( //					mappedClass, getterNames, setterNames, propTypes //			);",,,unknown,no,0
,"/*public boolean dropTemporaryTableAfterUse() {		//we have to, because postgres sets current tx		//to rollback only after a failed create table		return true;	}*/",,,unknown,no,0
,//materialize associations (and initialize the object) later,,,unknown,no,0
,"//do two passes, for collection property-ref!",,,unknown,no,0
,"// The user requested a ""greater"" (i.e. more restrictive) form of // pessimistic lock",,,unknown,no,0
,//don't need filters for the static loaders,,,unknown,no,0
,// hibernate seems to ignore this type...,,,unknown,no,0
,// invokeinterface // invoke Enabled.getInterceptFieldCallback(),,,unknown,no,0
,// GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// embedded composite ids ( alias.idname1, alias.idname2 )",,,unknown,no,0
,"// we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flush",,,unknown,no,0
,"// special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expression",,,unknown,no,0
,"// IMPL NOTE : due to the delayed population of setters (setters cached // 		for performance), we really cannot pro0perly define equality for // 		this transformer",,,unknown,no,0
,// ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);,,,unknown,no,0
,// we have a mapped identifier property and the root of // the incoming property path matched that identifier // property,,,unknown,no,0
,//	void setShowSqlEnabled(boolean b) { //		showSql = b; //	} // //	void setFormatSqlEnabled(boolean b) { //		formatSql = b; //	},,,unknown,no,0
,//			sqlAliasSuffixes[i] = element.getColumnAliasSuffix();,,,unknown,no,0
,// for some reason the antlr.CommonAST initialization routines force // this method to get called twice.  The first time with an empty string,,,unknown,no,0
,"// maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the moment",,,unknown,no,0
,"// we are using ""all"" or ""dirty"" property-based optimistic locking",,,unknown,no,0
,// Informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//		String provider = properties.getProperty( Environment.BYTECODE_PROVIDER ); //		log.info( ""Bytecode provider name : "" + provider ); //		BytecodeProvider bytecodeProvider = buildBytecodeProvider( provider ); //		settings.setBytecodeProvider( bytecodeProvider );",,,unknown,no,0
,//information about all properties in class hierarchy,,,unknown,no,0
,// The cache provider is needed when we either have second-level cache enabled // or query cache enabled.  Note that useSecondLevelCache is enabled by default,,,unknown,no,0
,// increment the version number (if necessary),,,unknown,no,0
,//use dialect default properties,,,unknown,no,0
,// for objects that came in via update(),,,unknown,no,0
,"// mappings might contain either the ""raw"" extends name (in the case of // an entity-name mapping) or a FQN (in the case of a POJO mapping).",,,unknown,no,0
,//to stop the class from being unloaded,,,unknown,no,0
,"// for non-inverse one-to-many, with a not-null fk, add a backref!",,,unknown,no,0
,//        },,,unknown,no,0
,// contained elements:,,,unknown,no,0
,// the object is transient or detached,,,unknown,no,0
,// Now update only the tables with dirty properties (and the table with the version number),,,unknown,no,0
,// Render the SQL query,,,unknown,no,0
,// not supported,,,unknown,no,0
,// Always add the collection's query spaces.,,,unknown,no,0
,// Chop off the rest of the tree.,,,unknown,no,0
,//a newly wrapped collection is NOT dirty (or we get unnecessary version updates),,,unknown,no,0
,// meant to handle dynamic instantiation queries...,,,unknown,no,0
,// new collections that get found + wrapped // during flush shouldn't be ignored,,,unknown,no,0
,// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// if we instantiate a collection during the flush() process, // we must ignore it for the rest of the flush()",,,unknown,no,0
,// Need to use the identifier type of the collection owner // since the incoming is value is actually the owner's id. // Using the collection's key type causes problems with // property-ref keys...,,,unknown,no,0
,//swaldman 2006-08-28: define c3p0-style configuration parameters for properties with //                     hibernate-specific overrides to detect and warn about conflicting //                     declarations,,,unknown,no,0
,// Default to sharing the entity cache if there is one,,,unknown,no,0
,//a shortcut if its location didn't change!,,,unknown,no,0
,// the class hierarchy structure,,,unknown,no,0
,"// For the case of dynamic-insert=""false"", use the static SQL",,,unknown,no,0
,"// For the case of dynamic-insert=""false"", use the static SQL",,,unknown,no,0
,"//the user visible aliases, which are unknown to the superclass, //these are not the actual ""physical"" SQL aliases",,,unknown,no,0
,"// For the case of dynamic-insert=""true"", we need to generate the INSERT SQL",,,unknown,no,0
,"// if it was a reference to self, don't need to nullify // unless we are using native id generation, in which // case we definitely need to nullify",,,unknown,no,0
,"// For the case of dynamic-insert=""true"", we need to generate the INSERT SQL",,,unknown,no,0
,"//the BLOB type requires a size arguement - this defaults to //bytes - no arg defaults to 1 whole byte! //other argument mods include K - kilobyte, M - megabyte, G - gigabyte. //refer to the PBdevelopers guide for more info.",,,unknown,no,0
,// detached collections that get found + reattached // during flush shouldn't be ignored,,,unknown,no,0
,// revert to traditional hibernate behavior of setting initialPoolSize to minPoolSize // unless otherwise specified with a c3p0.*-style parameter.,,,unknown,no,0
,// we need to utilize dynamic delete statements,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//NOTE EARLY EXIT!,,,unknown,no,0
,/*package*/,,,unknown,no,0
,//get 'em in the right order (not that it really matters),,,unknown,no,0
,// inserts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//skip the driving table,,,unknown,no,0
,// aliases named identifier ( alias.idname ),,,unknown,no,0
,//notice that we skip the first table; it is the driving table!,,,unknown,no,0
,"// more specifically : ""datetime [op] ?"" //      1) if the operator is MINUS, we really cannot determine //          the expected type as either another datetime or //          numeric would be valid //      2) if the operator is PLUS, the param needs to be of //          some numeric type",,,unknown,no,0
,//all joins join to the pk of the driving table,,,unknown,no,0
,// used to set the type of the parent dot node,,,unknown,no,0
,"// Essentially: // 1) If we have a local (Hibernate) transaction in progress //      and it already has the UserTransaction cached, use that //      UserTransaction to determine the status. // 2) If a transaction manager has been located, use //      that transaction manager to determine the status. // 3) Finally, as the last resort, try to lookup the //      UserTransaction via JNDI and use that to determine the //      status.",,,unknown,no,0
,"//final boolean forceCacheRefresh,",,,unknown,no,0
,"/*public boolean equals(Object other) {		read();		return bag.equals(other);	}	public int hashCode(Object other) {		read();		return bag.hashCode();	}*/",,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,"// otherwise, utilize the static delete statements",,,unknown,no,0
,//columns.add(columnName); //aliases.add(tableAlias);,,,unknown,no,0
,// we have the form: trim(trimSource) //      so we trim leading and trailing spaces,,,unknown,no,0
,"// remove initial "" and """,,,unknown,no,0
,// We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400,,,unknown,no,0
,// String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// determine if the collection elements are entities...,,,unknown,no,0
,//Render the SQL query,,,unknown,no,0
,//check if the detached object being merged is the parent,,,unknown,no,0
,// Write any appropriate versioning conditional parameters,,,unknown,no,0
,//	private List collectionOwnerAliases = new ArrayList(); //	private List collectionAliases = new ArrayList(); //	private List collectionPersisters = new ArrayList(); //	private List collectionResults = new ArrayList();,,,unknown,no,0
,"/**	 * Build a ResultSetMappingDefinition given a containing element for the ""return-XXX"" elements	 *	 * @param resultSetElem The element containing the return definitions.	 * @param path No clue...	 * @param mappings The current processing state.	 * @return The description of the mappings...	 */",,,unknown,no,0
,// object have been loaded with setReadOnly(true); HHH-2236,,,unknown,no,0
,// starting index,,,unknown,no,0
,//note: updates to joined tables can't be batched...,,,unknown,no,0
,"// if not ""get"", then try ""is""",,,unknown,no,0
,//stops flush being called multiple times if this method is recursively called,,,unknown,no,0
,"//if all fields are null, we might need to delete existing row",,,unknown,no,0
,// actual cache of the entries.  soft references are used for both the keys and the // values here since the values pertaining to the MRU entries are kept in a // seperate hard reference cache (to avoid their enqueuement/garbage-collection).,,,unknown,no,0
,// This is the root level node. // Generate an explicit from clause at the root.,,,unknown,no,0
,"//don't bother trying to update, we know there is no row there yet",,,unknown,no,0
,//a proxy cannot be transient and it breaks ForeignKeys.isTransient,,,unknown,no,0
,"// registerColumnType(Types.VARBINARY, ""CHARACTER($l)""); // registerColumnType(Types.BLOB, ""CHARACTER($l)"" );  // For use prior to CP 11.0 // registerColumnType(Types.CLOB, ""CHARACTER($l)"" );",,,unknown,no,0
,// Write the values of fields onto the prepared statement - we MUST use the state at the time the // insert was issued (cos of foreign key constraints). Not necessarily the object's current state,,,unknown,no,0
,// Do the key. The key is immutable so we can use the _current_ object state - not necessarily // the state at the time the delete was issued,,,unknown,no,0
,// Let return-propertys override whatever the persister has for aliases.,,,unknown,no,0
,// We should use the _current_ object state (ie. after any updates that occurred during flush),,,unknown,no,0
,// might need to run a different filter entirely after the flush // because the collection role may have changed,,,unknown,no,0
,//abort the save (the object is already saved by a circular cascade),,,unknown,no,0
,"// For the case of dynamic-update=""false"", or no snapshot, we use the static SQL",,,unknown,no,0
,"/*rootTableName = persistentClass.getRootTable().getQualifiedName( 				factory.getDialect(), 				factory.getDefaultCatalog(), 				factory.getDefaultSchema() 		);*/",,,unknown,no,0
,"// --Commented out by Inspection (12/4/04 9:10 AM): public abstract void addCondition(String alias, String[] columns, String condition);",,,unknown,no,0
,// Default to collections sharing entity cache if there is one,,,unknown,no,0
,// merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// For the case of dynamic-update=""true"", we need to generate the UPDATE SQL",,,unknown,no,0
,//int result = 17; //result = 37 * result + type.hashCode(); //result = 37 * result + ( value==null ? 0 : value.hashCode() ); //return result;,,,unknown,no,0
,"// For many-to-many joins, use the tablename from the queryable collection for the default text.",,,unknown,no,0
,/* COLUMN and TABLE should be renamed but it would break the public API */,,,unknown,no,0
,// note that if we load this collection from a cartesian product // the multiplicity would be broken ... so use an idbag instead,,,unknown,no,0
,// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// loop through all the associations of the current entity and make sure that they are processed // before the current batch number,,,unknown,no,0
,"//note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update //	  oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)",,,unknown,no,0
,// can't cache this stuff either (per-invocation) // we are given a map of user-alias -> lock mode // create a new map of sql-alias -> lock mode,,,unknown,no,0
,"// amazingly, these two will work because AbstractCollection // uses iterator() to fill the array",,,unknown,no,0
,"// local cache, so we use synchronization",,,unknown,no,0
,//		 You may still have other ResultSets or update counts left to process here //		 but you can't do it now or the ResultSet you just got will be closed,,,unknown,no,0
,// Get the caller,,,unknown,no,0
,//re-snapshot,,,unknown,no,0
,//optimization //optimization,,,unknown,no,0
,// the map of batch numbers to EntityInsertAction lists,,,unknown,no,0
,//optimization,,,unknown,no,0
,// handle the (assumed) valid cases: // #1 - the only valid datetime addition synatx is one or the other is a datetime (but not both),,,unknown,no,0
,//value is the entity name,,,unknown,no,0
,"// HHH-276 : implied joins in a subselect where clause - The destination needs to be added // to the destination's from clause. // Not sure if this is will fix everything, but it works.",,,unknown,no,0
,//Blobs are ignored by merge(),,,unknown,no,0
,"// this property belongs to the table and it is not specifically // excluded from optimistic locking by optimistic-lock=""false""",,,unknown,no,0
,//lobs cannot be compared,,,unknown,no,0
,// persists don't cascade to uninitialized collections,,,unknown,no,0
,// create one,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Add the type to the list of returned sqlResultTypes.,,,unknown,no,0
,// we found it in the temp PC.  Should indicate we are in the midst of processing a result set // containing eager fetches via join fetch,,,unknown,no,0
,"// If there is no WHERE node, make one.",,,unknown,no,0
,"// for expected parameter type injection, we expect that the lhs represents // some form of property ref and that the children of the in-list represent // one-or-more params.",,,unknown,no,0
,// might happen with a managed connection,,,unknown,no,0
,"// otherwise, perform a ""deep equivalence"" check...",,,unknown,no,0
,// Generate the inner join -- The elements need to be joined to the collection they are in.,,,unknown,no,0
,"// we don't need to worry about any condition in the ON clause // here (toFromFragmentString), since anything in the ON condition // is already applied to the whole query",,,unknown,no,0
,// the difficulty here is exactly what do we update in order to // force the version to be incremented in the db...,,,unknown,no,0
,// prefer re-generation of identity!,,,unknown,no,0
,// for convenience to save some lookups,,,unknown,no,0
,// metaType is assumed to be single-column type,,,unknown,no,0
,"// If this is an implied join in a from element, then use the impled join type which is part of the // tree parser's state (set by the gramamar actions).",,,unknown,no,0
,"/*sqlResultTypeList,*/",,,unknown,no,0
,// then handle any user-defined entity modes...,,,unknown,no,0
,//memory optimization,,,unknown,no,0
,// we need to strip off the embedded parens so that sql-gen does not double these up,,,unknown,no,0
,// Set up the cache factory,,,unknown,no,0
,// Use the table fromElement and the property name to get the array of column names.,,,unknown,no,0
,// Add the token to the AST.,,,unknown,no,0
,"// check to see if our ""propPath"" actually // represents a property on the persister",,,unknown,no,0
,//tolerates nulls,,,unknown,no,0
,//named query parameter,,,unknown,no,0
,//xml is the entity name,,,unknown,no,0
,"//This solution would allow us to eliminate the owner arg to disassemble(), but //what if the collection was null, and then later had elements added? seems unsafe //session.getPersistenceContext().getCollectionEntry( (PersistentCollection) value ).getKey();",,,unknown,no,0
,//	public List getCollectionAliases() { //		return collectionAliases; //	} // //	/*public List getCollectionOwners() { //		return collectionOwners; //	}*/ // //	public List getCollectionOwnerAliases() { //		return collectionOwnerAliases; //	} // //	public List getCollectionPersisters() { //		return collectionPersisters; //	} // //	public Map getAlias2Persister() { //		return alias2Persister; //	} // //	/*public boolean isCollectionInitializer() { //		return isCollectionInitializer; //	}*/ // ////	public List getPersisters() { ////		return persisters; ////	} // //	public Map getAlias2OwnerAlias() { //		return alias2OwnerAlias; //	} // //	public List getScalarTypes() { //		return scalarTypes; //	} //	public List getScalarColumnAliases() { //		return scalarColumnAliases; //	} // //	public List getPropertyResults() { //		return propertyResults; //	} // //	public List getCollectionPropertyResults() { //		return collectionResults; //	} // // //	public Map getAlias2Return() { //		return alias2Return; //	},,,unknown,no,0
,//EARLY EXIT!,,,unknown,no,0
,"// An ident node can represent an index expression if the ident // represents a naked property ref //      *Note: this makes the assumption (which is currently the case //      in the hql-sql grammar) that the ident is first resolved //      itself (addrExpr -> resolve()).  The other option, if that //      changes, is to call resolve from here; but it is //      currently un-needed overhead.",,,unknown,no,0
,//NOTE: this is not updated when properties are fetched lazily!,,,unknown,no,0
,"// Regions can get instantiated in the course of normal work (e.g. // a named query region will be created the first time the query is // executed), so suspend any ongoing tx",,,unknown,no,0
,"// isTransactionCallbackRegistered denotes whether any Hibernate // Transaction has registered as a callback against this // JDBCContext; only one such callback is allowed.  Directly // serializing this value causes problems with JDBCTransaction, // or really any Transaction impl where the callback is local // to the Transaction instance itself, since that Transaction // is not serialized along with the JDBCContext.  Thus we // handle that fact here explicitly...",,,unknown,no,0
,//note: this affects the return value!,,,unknown,no,0
,// we don't need to worry about existing version being uninitialized // because this block isn't called by a re-entrant load (re-entrant // loads _always_ have lock mode NONE),,,unknown,no,0
,//collection.clearDirty(),,,unknown,no,0
,"// Register the FromElement with the FROM clause, now that we have the names and aliases.",,,unknown,no,0
,//not final because proxy factory creation can fail,,,unknown,no,0
,"// Oracle driver reports to support getGeneratedKeys(), but they only // support the version taking an array of the names of the columns to // be returned (via its RETURNING clause).  No other driver seems to // support this overloaded version.",,,unknown,no,0
,//		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();,,,unknown,no,0
,// Add the new node to the map so that we don't create it twice.,,,unknown,no,0
,"// found a ctor, but it was not publicly accessible so try to request accessibility",,,unknown,no,0
,// not final-static to avoid possible classcast exceptions if using different oracle drivers.,,,unknown,no,0
,// ignore this row of results! Note the early exit,,,unknown,no,0
,"// RDMS has no known variation of a ""SELECT ... FOR UPDATE"" syntax...",,,unknown,no,0
,"// ""current"" means the reference that was found during flush() ",,,unknown,no,0
,// Create SQL_TOKEN nodes for the columns.,,,unknown,no,0
,// ATTRIBUTES USED ONLY DURING FLUSH CYCLE,,,unknown,no,0
,"// Generate an 2d array of column names, the first dimension is parallel with the // return types array.  The second dimension is the list of column names for each // type.",,,unknown,no,0
,"// Add the second join, the one that ends in the destination table.",,,unknown,no,0
,"// first, break down the returns into maps keyed by alias // so that role returns can be more easily resolved to their owners",,,unknown,no,0
,// allow the CollectionSnapshot to be serialized,,,unknown,no,0
,// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// session-start/post-flush persistent state,,,unknown,no,0
,"// if the original is a PersistentCollection, and that original // was not flagged as dirty, then reset the target's dirty flag // here after the copy operation. // </p> // One thing to be careful of here is a ""bare"" original collection // in which case we should never ever ever reset the dirty flag // on the target because we simply do not know...",,,unknown,no,0
,// superclass entity-name,,,unknown,no,0
,// First allow the actual type to control the return value. (the actual underlying sqltype could actually be different),,,unknown,no,0
,// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// #3 - note that this is also true of ""datetime - :param""...",,,unknown,no,0
,// Collection Types:,,,unknown,no,0
,//use the id column alias,,,unknown,no,0
,// Get ready to start adding nodes.,,,unknown,no,0
,// Constructors are always considered scalar results.,,,unknown,no,0
,// legacy behavior (with no abstract attribute specified),,,unknown,no,0
,// The 'from element' that represents the elements of the collection.,,,unknown,no,0
,//collection.clearDirty(),,,unknown,no,0
,"// during flush, we navigate the object graph to // collections and decide what to do with them",,,unknown,no,0
,// cascade-save to collections AFTER the collection owner was saved,,,unknown,no,0
,// Multi-param string dialect functions...,,,unknown,no,0
,// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// You may still have other ResultSets or update counts left to process here  // but you can't do it now or the ResultSet you just got will be closed ,,,unknown,no,0
,"//init the aliases, after initing the constructornode",,,unknown,no,0
,"// cache the actual id of the object, not the value of the // property-ref, which might not be initialized",,,unknown,no,0
,"// ""loaded"" means the reference that is consistent  // with the current database state",,,unknown,no,0
,"// ""pass along"" our initial embedded parameter node(s) to the first generated // sql fragment so that it can be handled later for parameter binding...",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// End unit of work,,,unknown,no,0
,// ROW ID,,,unknown,no,0
,//MULTITABLES,,,unknown,no,0
,//noop,,,unknown,no,0
,"// here, we work under the following assumptions: //      ------------ valid cases -------------------------------------- //      1) datetime + {something other than datetime} : always results //              in a datetime ( db will catch invalid conversions ) //      2) datetime - datetime : always results in a DOUBLE //      3) datetime - {something other than datetime} : always results //              in a datetime ( db will catch invalid conversions ) //      ------------ invalid cases ------------------------------------ //      4) datetime + datetime //      5) {something other than datetime} - datetime //      6) datetime * {any type} //      7) datetime / {any type} //      8) {any type} / datetime // doing so allows us to properly handle parameters as either the left // or right side here in the majority of cases",,,unknown,no,0
,// an unfetched association can only point to // an entity that already exists in the db,,,unknown,no,0
,//cache the hashcode,,,unknown,no,0
,//unwrap it,,,unknown,no,0
,//cache this,,,unknown,no,0
,"// if the types report logical equivalence, return true...",,,unknown,no,0
,//different nullability rules for pk/fk,,,unknown,no,0
,// grab its state from the ResultSet and keep it in the Session // (but don't yet initialize the object itself) // note that we acquire LockMode.READ even if it was not requested,,,unknown,no,0
,// Chop off the rest of the tree.,,,unknown,no,0
,// Forcefully remove leading ands from where fragments; the grammar will // handle adding them,,,unknown,no,0
,// We ignore minimalPutOverride. JBossCache putForExternalRead is // already about as minimal as we can get; it will promptly return // if it discovers that the node we want to write to already exists,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//or Types.LONGVARCHAR?,,,unknown,no,0
,// The where clause was added to eliminate this statement from Brute Force Searches.,,,unknown,no,0
,// Return StringBuffer content as a large String,,,unknown,no,0
,// The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation level,,,unknown,no,0
,// Fetch Reader content up to the end - and put characters in a StringBuffer,,,unknown,no,0
,"// If there is no data type for this node, and we're at the end of the path (top most dot node), then // this might be a Java constant.",,,unknown,no,0
,"// if the corresponding SQL value is NULL, the reader we got is NULL as well",,,unknown,no,0
,// let the interceptor inspect the instance to decide,,,unknown,no,0
,"/*	 * The types represented in the SQL result set.	 *	 * @return The types represented in the SQL result set.	 */",,,unknown,no,0
,// let the persister inspect the instance to decide,,,unknown,no,0
,// context-entity-identifier returns null explicitly if the entity // is not associated with the persistence context; so make some // deeper checks...,,,unknown,no,0
,//NOOP,,,unknown,no,0
,//remember the uk value,,,unknown,no,0
,// collections cannot be compared,,,unknown,no,0
,//the first key found after the given key,,,unknown,no,0
,//Clobs are ignored by merge() operation,,,unknown,no,0
,//lobs cannot be compared,,,unknown,no,0
,// putfield // new value of the field,,,unknown,no,0
,//int count = 0;,,,unknown,no,0
,"// we use the assumed value, if there is one, to avoid hitting // the database",,,unknown,no,0
,// the CascadingAction contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//nothing to do,,,unknown,no,0
,//nothing to do,,,unknown,no,0
,"//public Object instantiate(Object parent, SessionImplementor session) throws HibernateException;",,,unknown,no,0
,// Establish the region root node with a non-locking data version,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// if there is no TM configured, we will not be able to access // the javax.transaction.Transaction object in order to // register a synch anyway.",,,unknown,no,0
,// Create a new FILTERS node as a parent of all filters,,,unknown,no,0
,// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//			        ( implied && DotNode.useThetaStyleImplicitJoins ) ) {,,,unknown,no,0
,// or BYTE // or TEXT? // or MONEY,,,unknown,no,0
,"//			final List extendsQueue,",,,unknown,no,0
,"// If close() is called, guarantee unbind()",,,unknown,no,0
,// Possibly handle :something parameters for the query ?,,,unknown,no,0
,"//values is not null and is checkable, we'll look deeper",,,unknown,no,0
,"// Add a zero (or quite low) timeout option so we don't block. // Ignore any TimeoutException. Basically we forego caching the // query result in order to avoid blocking. // Reads are done with suspended tx, so they should not hold the // lock for long.  Not caching the query result is OK, since // any subsequent read will just see the old result with its // out-of-date timestamp; that result will be discarded and the // db query performed again.",,,unknown,no,0
,//check basic level one nullablilty,,,unknown,no,0
,"// If the from element represents a JOIN_FRAGMENT and it is // a theta-style join, convert its type from JOIN_FRAGMENT // to FROM_FRAGMENT",,,unknown,no,0
,"// the current join represents the join between a many-to-many association table // and its ""target"" table.  Here we need to apply any additional filters // defined specifically on the many-to-many",,,unknown,no,0
,// Need to parse off the column qualifiers; this is assuming (which is true as of now) // that this is only used from update and delete HQL statement parsing,,,unknown,no,0
,// this should not happen since the DTD prevents it,,,unknown,no,0
,"// For an explicit many-to-many relationship, add a second join from the intermediate  // (many-to-many) table to the destination table.  Also, make sure that the from element's  // idea of the destination is the destination table.",,,unknown,no,0
,// copied from Session:,,,unknown,no,0
,// collections of values,,,unknown,no,0
,//return AssociationType.FOREIGN_KEY_TO_PARENT; //this is better but causes a transient object exception...,,,unknown,no,0
,// identifier-commalist,,,unknown,no,0
,// Look through the FromElement's children to find any collections of values that should be fetched...,,,unknown,no,0
,"// If the uresolved property path isn't set yet, just use the property name.",,,unknown,no,0
,"// visit width-first, then depth",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Get all the select expressions (that we just generated) and render the select.,,,unknown,no,0
,// Make sure JBC doesn't look one up,,,unknown,no,0
,"//for non null args, check for components and elements containing components",,,unknown,no,0
,"// If we want to handle it bidirectional and detached, we also need to load this // collection with an eager outer-join fetch, this time with Criteria and not HQL:",,,unknown,no,0
,//cache the hashcode,,,unknown,no,0
,"//st.setDate( index,  new Date( cal.getTimeInMillis() ), cal ); //JDK 1.5 only",,,unknown,no,0
,// LIMIT support (ala TOP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//do the test,,,unknown,no,0
,// after *all* persisters and named queries are registered,,,unknown,no,0
,//swallow it (the transaction _was_ successful or successfully rolled back),,,unknown,no,0
,// at least one is a plain old Date,,,unknown,no,0
,"// First, collect all of the select expressions. // NOTE: This must be done *before* invoking setScalarColumnText() because setScalarColumnText() // changes the AST!!!",,,unknown,no,0
,// both are Timestamps,,,unknown,no,0
,// from javax.naming.Referenceable,,,unknown,no,0
,//arbitrary on clause ignored!!,,,unknown,no,0
,"/*public PropertyProjection project() {		return Projections.property(getPropertyName());	}*/",,,unknown,no,0
,"//st.setTimestamp( index,  new Timestamp( cal.getTimeInMillis() ), cal ); //JDK 1.5 only",,,unknown,no,0
,"// for regression testing against output from the old parser... // found it easiest to simply reorder the FromElements here into ascending order // in terms of injecting them into the resulting sql ast in orders relative to those // expected by the old parser; this is definitely another of those ""only needed // for regression purposes"".  The SyntheticAndFactory, then, simply injects them as it // encounters them.",,,unknown,no,0
,"// Here we don't want to suspend the tx. If we do: // 1) We might be caching query results that reflect uncommitted // changes. No tx == no WL on cache node, so other threads // can prematurely see those query results // 2) No tx == immediate replication. More overhead, plus we // spread issue #1 above around the cluster",,,unknown,no,0
,// IDENT might be the name of a class.,,,unknown,no,0
,"//		registerColumnType( Types.VARCHAR, 16777215, ""mediumtext"" );",,,unknown,no,0
,//test out the optimizer:,,,unknown,no,0
,"// We have the JBCWriteMutex, so no other *local* thread will  // be trying to write this key.  // It's possible here some remote thread has come in and // changed the values again, but since we are reading the // values to write to JBC right now, we know we are writing // the latest values; i.e. we don't assume that what we cached // in entry.update() above is what we should write to JBC *now*. // Our write could be redundant, i.e. we are writing what // some remote thread just came in an wrote.  There is a chance  // that yet another remote thread will update us, and we'll then // overwrite that later data in JBC.  But, all remote nodes will // ignore that change in their localCache; the only place it  // will live will be in JBC, where it can only effect the  // initial state transfer values on newly joined nodes  // (i.e. populateLocalCache()).",,,unknown,no,0
,//persistent collections may have components,,,unknown,no,0
,// should be safe to only ever expect EntityPersister references here,,,unknown,no,0
,// now rebuild the insertions list. There is a batch for each entry in the name list.,,,unknown,no,0
,//ATTRIBUTES MAINTAINED BETWEEN FLUSH CYCLES,,,unknown,no,0
,"// this has been shown to happen occasionally in rare cases // when using a transaction manager + transaction-timeout // where the timeout calls back through Hibernate's // registered transaction synchronization on a separate // ""reaping"" thread.  In cases where that reaping thread // executes through this block at the same time the main // application thread does we can get into situations where // these CMEs occur.  And though it is not ""allowed"" per-se, // the end result without handling it specifically is infinite // looping.  So here, we simply break the loop",,,unknown,no,0
,/*package*/,,,unknown,no,0
,"// we need to dirty check many-to-ones with not-found=""ignore"" in order  // to update the cache (not the database), since in this case a null // entity reference can lose information",,,unknown,no,0
,/*package*/,,,unknown,no,0
,// PROPERTIES,,,unknown,no,0
,"//even on inverse=""true""",,,unknown,no,0
,// Impl note: takes advantage of the fact that an escpaed single quote // embedded within a quote-block can really be handled as two seperate // quote-blocks for the purposes of this method...,,,unknown,no,0
,//not sure if this would ever be null but wanted to be careful,,,unknown,no,0
,// cascade the refresh prior to refreshing this entity,,,unknown,no,0
,/*package*/,,,unknown,no,0
,"// two conditions where we need to transform this to a theta-join syntax: //      1) 'elem' is the ""root from-element"" in correlated subqueries //      2) The DotNode.useThetaStyleImplicitJoins has been set to true //          and 'elem' represents an implicit join",,,unknown,no,0
,//null caused some problems,,,unknown,no,0
,"// then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available",,,unknown,no,0
,//HashMap columnsUnique = new HashMap();,,,unknown,no,0
,//handle a property-ref,,,unknown,no,0
,// Handle any filters applied to this collection,,,unknown,no,0
,"/**	 * Set a custom entity resolver. This entity resolver must be	 * set before addXXX(misc) call.	 * Default value is {@link org.hibernate.util.DTDEntityResolver}	 *	 * @param entityResolver entity resolver to use	 */",,,unknown,no,0
,// Detect discriminator values...,,,unknown,no,0
,//for MySQL,,,unknown,no,0
,"//	public ComponentMetamodel(Component component, SessionFactoryImplementor sessionFactory) {",,,unknown,no,0
,// register hibernate types for default use in scalar sqlquery type auto detection,,,unknown,no,0
,"// If true then execute db updates, otherwise just generate and display updates",,,unknown,no,0
,// SQLFunction implementation,,,unknown,no,0
,"//actually, this last test is probably unnecessary, since  //beforeCompletion() doesn't get called during rollback",,,unknown,no,0
,"// here, we have two possibilities: // 		1) the property-name matches the explicitly identifier property name //		2) the property-name matches the implicit 'id' property name",,,unknown,no,0
,"// swallow it, and continue to roll back JTA transaction",,,unknown,no,0
,"//if an exception occurs during flush, user must call rollback()",,,unknown,no,0
,//its already loaded so don't need to hydrate it,,,unknown,no,0
,// Create an DotNode AST for the path and resolve it.,,,unknown,no,0
,// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//final boolean forceCacheRefresh,",,,unknown,no,0
,// we need to step through the rows one row at a time (slow),,,unknown,no,0
,/*<String>*/,,,unknown,no,0
,// we only release the connection,,,unknown,no,0
,"//if an exception occurs during flush, user must call rollback()",,,unknown,no,0
,// Create an OuterJoinGenerator for this dialect.,,,unknown,no,0
,// COMPOSITE-ID,,,unknown,no,0
,//woops we got an instance of another class hierarchy branch,,,unknown,no,0
,/*NativeSQLQueryReturn*/,,,unknown,no,0
,// only carry on if the method has no parameters,,,unknown,no,0
,// deprecated option...,,,unknown,no,0
,//we only check the version when _upgrading_ lock modes,,,unknown,no,0
,"//dontSpace.add(""'"");",,,unknown,no,0
,// if the condition is not already there...,,,unknown,no,0
,// we found a collection element in the result set,,,unknown,no,0
,"// then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available",,,unknown,no,0
,//return lhsPersister.getSubclassPropertyColumnNames(property);,,,unknown,no,0
,//unquotedIdentifierColumnName = identifierColumnAlias;,,,unknown,no,0
,// adds remove as a sort-of alias for delete...,,,unknown,no,0
,"// does not handle arrays (thats ok, cos they can't be lazy) // or newly instantiated collections, so we can do the cast",,,unknown,no,0
,"// otherwise, the proxy was pruned during the serialization process",,,unknown,no,0
,// Allows various loaders (ok mainly the QueryLoader :) to check // whether scrolling of their result set should be allowed. // // By default it is allowed.,,,unknown,no,0
,//check if the managed object is the parent,,,unknown,no,0
,/////////////////////////////////////////////////////////////////////// // Prepare persisters and link them up with their cache // region/access-strategy,,,unknown,no,0
,// does this entity entry pertain to the entity persister in which we are interested (owner)?,,,unknown,no,0
,"// According to both the ANSI-SQL and JPA specs, trim takes a variable number of parameters between 1 and 4. // at least one paramer (trimSource) is required.  From the SQL spec: // // <trim function> ::= //      TRIM <left paren> <trim operands> <right paren> // // <trim operands> ::= //      [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> // // <trim specification> ::= //      LEADING //      | TRAILING //      | BOTH // // If <trim specification> is omitted, BOTH is assumed. // If <trim character> is omitted, space is assumed",,,unknown,no,0
,// iterate all the entities currently associated with the persistence context.,,,unknown,no,0
,"//special case ... this is the leaf of the containment graph, even though not immutable",,,unknown,no,0
,"/*public boolean isNonExistant(EntityUniqueKey key) {		return nonExistentEntityUniqueKeys.contains(key);	}*/",,,unknown,no,0
,"// generate id select fragment and then property select fragment for // each expression, just like generateSelectFragments().",,,unknown,no,0
,"/*public boolean isNonExistant(EntityKey key) {		return nonExistantEntityKeys.contains(key);	}*/",,,unknown,no,0
,//do nothing,,,unknown,no,0
,"//private static final Alias DEFAULT_ALIAS = new Alias(10, null);",,,unknown,no,0
,// refresh doesn't cascade to uninitialized collections,,,unknown,no,0
,// Get the caller principals,,,unknown,no,0
,// saves / updates don't cascade to uninitialized collections,,,unknown,no,0
,//EARLY EXIT,,,unknown,no,0
,// create our own copy of the user-supplied tuplizer impl map,,,unknown,no,0
,//$NON-NLS-1,,,unknown,no,0
,// strip off any leading 'and' token,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//$NON-NLS-1,,,unknown,no,0
,// then handle any user-defined entity modes...,,,unknown,no,0
,//$NON-NLS-1,,,unknown,no,0
,//		origin.addDestination( destination ); // This was the cause of HHH-242 //		origin.setType( FROM_FRAGMENT );			// Set the parent node type so that the AST is properly formed. // The destination node will have all the FROM text. // The parent node is a collection join too (voodoo - see JoinProcessor),,,unknown,no,0
,//$NON-NLS-1,,,unknown,no,0
,// add another (inner) nested select // add the main query // close off the inner nested select,,,unknown,no,0
,// determine the id getter and setter methods from the proxy interface (if any) // determine all interfaces needed by the resulting proxy,,,unknown,no,0
,"//if the identifier is quoted, remove the quotes",,,unknown,no,0
,// the outerJoinsAfterWhere needs to come before where clause to properly // handle dynamic filters,,,unknown,no,0
,// properly handle property-ref-based associations,,,unknown,no,0
,// null is not considered the same type as Integer. //$NON-NLS-1 //$NON-NLS-1,,,unknown,no,0
,"//		SQLQueryParser parser = new SQLQueryParser( //				sqlQuery, //				processor.getAlias2Persister(), //				processor.getAlias2Return(), //				aliases, //				collAliases, //				collPersisters, //				suffixes, //				collSuffixes //		); // //		sql = parser.process(); // //		namedParameterBindPoints = parser.getNamedParameters();",,,unknown,no,0
,//full joins are not supported.. yet!,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//truncate the identifier to the max alias length, less the suffix length",,,unknown,no,0
,// we can do the cast since orphan-delete does not apply to: // 1. newly instantiated collections // 2. arrays (we can't track orphans for detached arrays),,,unknown,no,0
,"// so the transaction is already rolled back, by JTA spec",,,unknown,no,0
,// this method is a noop if there is a Synchronization!,,,unknown,no,0
,//		 This assumes you will want to ignore any update counts ,,,unknown,no,0
,"/* will check current level if some of them are not null		 * or sublevels if they exist		 */",,,unknown,no,0
,// table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//		this.sessionFactory = sessionFactory;,,,unknown,no,0
,// sql server just returns automatically,,,unknown,no,0
,// cached for efficiency...,,,unknown,no,0
,"// Search for collections by reachability, updating their role. // We don't want to touch collections reachable from a deleted object",,,unknown,no,0
,//	private final SessionFactoryImplementor sessionFactory;,,,unknown,no,0
,"// our parent is another dot node, meaning we are being further dereferenced. // thus we need to generate a join unless the parent refers to the associated // entity's PK (because 'our' table would know the FK).",,,unknown,no,0
,"// found a ctor, but it was not publicly accessible so try to request accessibility",,,unknown,no,0
,"// hit the database, after checking the session cache for a snapshot",,,unknown,no,0
,"// put the ""standard"" tuplizers into the tuplizer map first",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// return false here, as most databases do not properly support this construct...",,,unknown,no,0
,// Build the dynamic-map tuplizer...,,,unknown,no,0
,"//return the id, so we can use it to reset the proxy id //return result;",,,unknown,no,0
,// We've been here before,,,unknown,no,0
,// if its an uninitialized proxy it can't be transient,,,unknown,no,0
,"// See if the entity is already bound to this session, if not look at the // entity identifier and assume that the entity is persistent if the // id is not ""unsaved"" (that is, we rely on foreign keys to keep // database integrity)",,,unknown,no,0
,"// then dom4j tuplizer, if dom4j representation is available",,,unknown,no,0
,"// Pointbase has no known variation of a ""SELECT ... FOR UPDATE"" syntax...",,,unknown,no,0
,"//it was not embedded, so the argument is just an id",,,unknown,no,0
,"// we have specialized case of a detached entity from the // perspective of the merge operation.  Specifically, we // have an incoming entity instance which has a corresponding // entry in the current persistence context, but registered // under a different entity instance",,,unknown,no,0
,"// then dom4j tuplizer, if dom4j representation is available",,,unknown,no,0
,//reset the id,,,unknown,no,0
,// else if it's elements changed,,,unknown,no,0
,// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id',,,unknown,no,0
,// the default is to simply not lazy fetch properties for now...,,,unknown,no,0
,"// Note: this simply constructs a ""raw"" SQL_TOKEN representing the // where fragment and injects this into the tree.  This ""works""; // however it is probably not the best long-term solution. // // At some point we probably want to apply an additional grammar to // properly tokenize this where fragment into constituent parts // focused on the operators embedded within the fragment.",,,unknown,no,0
,//reset the version,,,unknown,no,0
,"//if it is an uninitialized proxy, pointing //with this session, then when it is accessed, //the underlying instance will be ""contained""",,,unknown,no,0
,// CollectionPropertyMapping processes everything except 'index'.,,,unknown,no,0
,"//addInitializedCollection(collection, persister, id);",,,unknown,no,0
,//unquotedIdentifierColumnName = null;,,,unknown,no,0
,//where fragment must be empty!,,,unknown,no,0
,//return currentId;,,,unknown,no,0
,// lock doesn't cascade to uninitialized collections,,,unknown,no,0
,// force initialize!,,,unknown,no,0
,// add the current fragment to the THETA_JOINS node,,,unknown,no,0
,// miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// put the ""standard"" tuplizers into the tuplizer map first",,,unknown,no,0
,"//					int parameterStart = getWalker().getNumberOfParametersInSetClause(); //					List allParams = getIdSelectParameterSpecifications(); //					Iterator whereParams = allParams.subList( parameterStart, allParams.size() ).iterator();",,,unknown,no,0
,// or its key changed,,,unknown,no,0
,// Build the dynamic-map tuplizer...,,,unknown,no,0
,//this one needed only for guessEntityMode(),,,unknown,no,0
,// register the standard dialect resolver,,,unknown,no,0
,"// The current_timestamp is more accurate, but only known to be supported // in SQL Server 7.0 and later (i.e., Sybase not known to support it at all)",,,unknown,no,0
,// Fix up the resident flag,,,unknown,no,0
,// some collections are not lazy:,,,unknown,no,0
,// Don't hold a transactional lock for this ,,,unknown,no,0
,"// this property belongs to the table and it is not specifically // excluded from optimistic locking by optimistic-lock=""false""",,,unknown,no,0
,// 60 seconds,,,unknown,no,0
,"//will be ignored, using the existing Entry instead",,,unknown,no,0
,"//swallow, the transaction was finished",,,unknown,no,0
,"// First, try to find a matching constructor accepting a ViolatedConstraintNameExtracter param...",,,unknown,no,0
,"// for sane JEE/JTA containers, the transaction itself functions as its identifier...",,,unknown,no,0
,// loop through all the associated entities and make sure they have been // processed before the latest // batch associated with this entity type.,,,unknown,no,0
,"// WebSphere, however, is not a sane JEE/JTA container...",,,unknown,no,0
,"// Since the result set cursor is always left at the first // physical row after the ""last processed"", we need to jump // back one position to get the key value we are interested // in skipping",,,unknown,no,0
,// The 'from element' that the property is in.,,,unknown,no,0
,//null child could occur for no from clause in a filter,,,unknown,no,0
,"/*return that.type.equals(type) && 			EqualsHelper.equals(that.value, value);*/",,,unknown,no,0
,"//include the discriminator and class-level where, but not filters",,,unknown,no,0
,// HELLA IMPORTANT OPTIMIZATION!!!,,,unknown,no,0
,"// even though we might find a pre-existing element by join path, we may not be able to reuse it...",,,unknown,no,0
,// why is all others non final ?,,,unknown,no,0
,"// Does the LIMIT clause come at the start of the SELECT statement, rather than at the end?",,,unknown,no,0
,// all AliasToEntityMapResultTransformer are considered equal ~~~~~~~~~~~~~,,,unknown,no,0
,"//the following two lines were added to ensure that this.params is not null, which //can happen with two-deep nested subqueries",,,unknown,no,0
,///////////////////////////////////////////////////////////////////////////,,,unknown,no,0
,// create our own copy of the user-supplied tuplizer impl map,,,unknown,no,0
,// Need to use the identifier type of the collection owner // since the incoming is value is actually the owner's id. // Using the collection's key type causes problems with // property-ref keys...,,,unknown,no,0
,// this is a virtual id property...,,,unknown,no,0
,//Now write the values of fields onto the prepared statement,,,unknown,no,0
,// map of EntityMode -> Tuplizer,,,unknown,no,0
,//			ps.close(); //just close it; do NOT try to return it to the pool! //NOTE: early exit!,,,unknown,no,0
,// Make sure the root node for the region exists and  // has a DataVersion that never complains,,,unknown,no,0
,// (NOT (BETWEEN a b) ) => (NOT_BETWEEN a b),,,unknown,no,0
,// pre-determine and cache the hashcode,,,unknown,no,0
,// Set the attributes of the property reference expression.,,,unknown,no,0
,// Moved here from SelectClause [jsd],,,unknown,no,0
,"// for merging of versioned entities, we consider the version having // been changed only when: // 1) the two version values are different; //      *AND* // 2) The target actually represents database state! // // This second condition is a special case which allows // an entity to be merged during the same transaction // (though during a seperate operation) in which it was // originally persisted/saved",,,unknown,no,0
,// Create the join element under the from element.,,,unknown,no,0
,"// Does the collection referenced by this FromElement // specify an order-by attribute?  If so, attach it to // the query's order-by",,,unknown,no,0
,// Never evict this node,,,unknown,no,0
,//we can inner join to superclass tables (the row MUST be there) //we can never inner join to subclass tables,,,unknown,no,0
,//take a snapshot,,,unknown,no,0
,// the current batch number is the latest batch for this entity type.,,,unknown,no,0
,"// Fetch embedded identifiers propertynames from the ""virtual"" identifier component",,,unknown,no,0
,"// the entry will be removed after the flush, and will no longer // override the stale snapshot // This is now handled by removeEntity() in EntityDeleteAction //persistenceContext.removeDatabaseSnapshot(key);",,,unknown,no,0
,// aliases for composite-id's,,,unknown,no,0
,// Get the persister for the _subclass_,,,unknown,no,0
,"// Oracle driver reports to support getGeneratedKeys(), but they only // support the version taking an array of the names of the columns to // be returned (via its RETURNING clause).  No other driver seems to // support this overloaded version.",,,unknown,no,0
,"// if not wrappered yet, its dirty (this can't occur, because // we now always call wrap() before getting to here) // return ( ! (obj instanceof PersistentCollection) ) ? //true : searchForDirtyCollections( (PersistentCollection) obj, type );",,,unknown,no,0
,// disassemble named parameters,,,unknown,no,0
,"// we do not have to worry about queued additions to uninitialized // collections, since they can only occur for inverse collections!",,,unknown,no,0
,//assembled state gets put in a new array (we read from cache by value!),,,unknown,no,0
,// note: interfaces is assumed to already contain HibernateProxy.class,,,unknown,no,0
,// identifier-commalist,,,unknown,no,0
,// note: interfaces is assumed to already contain HibernateProxy.class,,,unknown,no,0
,// Execute the SQL:,,,unknown,no,0
,"//note: it is conceptually possible that a UserType could map null to //	  a non-null value, so the following is arguable:",,,unknown,no,0
,// The syntax used to add a foreign key constraint to a table.,,,unknown,no,0
,"// according to both the ANSI-SQL and EJB3 specs, trim can either take // exactly one parameter or a variable number of parameters between 1 and 4. // from the SQL spec: // // <trim function> ::= //      TRIM <left paren> <trim operands> <right paren> // // <trim operands> ::= //      [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> // // <trim specification> ::= //      LEADING //      | TRAILING //      | BOTH // // If only <trim specification> is omitted, BOTH is assumed; // if <trim character> is omitted, space is assumed",,,unknown,no,0
,// SUBCLASSES,,,unknown,no,0
,// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null // is an indication that the specified entity-name (this.getEntityName) should be used.,,,unknown,no,0
,"//throw new UnsupportedOperationException(""Can't write to a readonly object"");",,,unknown,no,0
,"// let this take precedence if defined, since it works for // assigned identifiers",,,unknown,no,0
,// %upper is deprecated,,,unknown,no,0
,// Use the lower case function name. // Remember whether we're in a SELECT clause or not.,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Pre-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// DISCRIMINATOR,,,unknown,no,0
,"// again, CCS did not have such a concept; but a reasonable // proximity is to clear the cache after transaction *as long as* // the underlying cache is not JTA aware.",,,unknown,no,0
,"// again, CCS did not have such a concept; however a reasonable // proximity is to clear the cache.  For non-transaction aware // caches, we will also do a clear at the end of the transaction",,,unknown,no,0
,// unfortunately not really safe to normalize this // to 1 as an initial value like we do the others // because we would not be able to control this if // we are using a sequence...,,,unknown,no,0
,// remove all collections for the entity from the session-level cache,,,unknown,no,0
,"//if there is no resulting row, return null",,,unknown,no,0
,// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"/*public static Object[] clone(Class elementClass, Object[] array) {		Object[] result = (Object[]) Array.newInstance( elementClass, array.length );		System.arraycopy(array, 0, result, 0, array.length);		return result;	}*/",,,unknown,no,0
,// SQL strings,,,unknown,no,0
,"// local cache, so we use synchronization",,,unknown,no,0
,//render the SQL,,,unknown,no,0
,//get em on the second pass!,,,unknown,no,0
,//figure out which formulas are needed,,,unknown,no,0
,"// it is possible for this method to be called during flush processing, // so make certain that we do not accidently initialize an uninitialized proxy",,,unknown,no,0
,//	private final List persisters = new ArrayList();,,,unknown,no,0
,"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",,,unknown,no,0
,//Access cached SQL,,,unknown,no,0
,"//propertyTableNumbersByName.put( prop.getName(), join );",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// classes mentioned in extends not available - so put it in queue,,,unknown,no,0
,"// If this is an entity and the property is the identifier property, then use getIdentifierType(). //      Note that the propertyName.equals( propertyPath ) checks whether we have a component //      key reference, where the component class property name is the same as the //      entity id property name; if the two are not equal, this is the case and //      we'd need to ""fall through"" to using the property mapping.",,,unknown,no,0
,// JOINS,,,unknown,no,0
,// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// invokeinterface // callback.write*(..),,,unknown,no,0
,"// Due to the complexity in initializing the SelectClause, do not generate one here. // If it is not found; simply return null... // // Also, do not cache since it gets generated well after we are created.",,,unknown,no,0
,"// we really could refresh the item if it // is not a lock, but it might be slower //return freshTimestamp < txTimestamp",,,unknown,no,0
,// convenience methods relating to operations across arrays of types...,,,unknown,no,0
,// create new lock that times out immediately,,,unknown,no,0
,// checkcast (case of primitive type) // invokevirtual (case of primitive type),,,unknown,no,0
,// checkcast // cast the bean into a raw bean,,,unknown,no,0
,"// for now, just ""re-flatten"" the metamodel since this is temporary stuff anyway (HHH-1907)",,,unknown,no,0
,// required to exception table // iconst_0 // i,,,unknown,no,0
,// synchronized to avoid multi-thread access issues; defined as method synch to avoid // potential deadlock issues due to nature of code.,,,unknown,no,0
,// CLASS + TABLE,,,unknown,no,0
,"// conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrap",,,unknown,no,0
,//private final Map propertyTableNumbersByName = new HashMap();,,,unknown,no,0
,"//NONE, because its the requested lock mode, not the actual! ",,,unknown,no,0
,//INITIALIZATION:,,,unknown,no,0
,// Code to handle subclasses of topClass,,,unknown,no,0
,// discriminator column,,,unknown,no,0
,//before adding to collection!,,,unknown,no,0
,// now look up the object we are really interested in! // (this lets us correctly handle proxies and multi-row // or multi-column queries),,,unknown,no,0
,// we can go straight to the first required row,,,unknown,no,0
,// the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this class,,,unknown,no,0
,// otherwise assume the parent is the the criteria that created us,,,unknown,no,0
,"// properties of this class, including inherited properties",,,unknown,no,0
,//decide which ResultSet to get the property value from:,,,unknown,no,0
,"// at this point we have (drivingSqlAlias) the SQL alias of the driving table // corresponding to the given user alias.  However, the driving table is not // (necessarily) the table against which we want to apply locks.  Mainly, // the exception case here is joined-subclass hierarchies where we instead // want to apply the lock against the root table (for all other strategies, // it just happens that driving and root are the same).",,,unknown,no,0
,/* | this | bean | args | i | raw bean | exception | */,,,unknown,no,0
,// Get the first child to be considered.  Sub-classes may do this differently in order to skip nodes that // are not select expressions (e.g. DISTINCT).,,,unknown,no,0
,// we *always* assume an instance with a null // identifier or no identifier property is unsaved!,,,unknown,no,0
,"//If the object is already loaded, return the loaded one",,,unknown,no,0
,// note that %string is deprecated,,,unknown,no,0
,// the column doesnt exist at all.,,,unknown,no,0
,// byte,,,unknown,no,0
,// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// below is for Cache' that don't have str in 2007.1 there is str and we register str directly,,,unknown,no,0
,// seems to not really... //	public boolean supportsRowValueConstructorSyntax() { //		return true; //	},,,unknown,no,0
,// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// invokeinterface,,,unknown,no,0
,// new // BulkAccessorException,,,unknown,no,0
,"// find the batch number associated with the current association, if any.",,,unknown,no,0
,/* local variables | this | callback | */,,,unknown,no,0
,// Configure the cache to use our TM,,,unknown,no,0
,"// putfield // put field ""$JAVASSIST_CALLBACK"" defined already",,,unknown,no,0
,// dup,,,unknown,no,0
,// all DistinctRootEntityResultTransformer are considered equal ~~~~~~~~~~~,,,unknown,no,0
,"// getfield // get field ""$JAVASSIST_CALLBACK"" defined already",,,unknown,no,0
,"//""as"" is not in KEYWORDS",,,unknown,no,0
,// *load_1 // each type,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//bad cast,,,unknown,no,0
,// return,,,unknown,no,0
,/*package*/,,,unknown,no,0
,"//tableName = mappings.getNamingStrategy().propertyToTableName( className, path );",,,unknown,no,0
,//Custom SQL,,,unknown,no,0
,//it might be an unwrapped collection reference! //try to find a wrapper (slowish),,,unknown,no,0
,"// if the property mapping consists of all formulas,  // make it insertable",,,unknown,no,0
,"// the user specifically supplied insert=""true"", // which constitutes an illegal combo",,,unknown,no,0
,"// if the property mapping consists of all formulas,  // make it non-updateable",,,unknown,no,0
,// null sql means that the only lazy properties // are shared PK one-to-one associations which are // handled differently in the Type#nullSafeGet code...,,,unknown,no,0
,"// ok in normal Hibernate usage to delete a detached entity; JPA however // forbids it, thus this is a hook for HEM to affect this behavior",,,unknown,no,0
,// this is the exception returned by ReflectHelper.getConstructor() if it cannot // locate an appropriate constructor,,,unknown,no,0
,// just ignore,,,unknown,no,0
,// automatically makes a column with the default name if none is specifed by XML,,,unknown,no,0
,"// essentially, if the real session is closed allow any // method call to pass through since the real session // will complain by throwing an appropriate exception; // NOTE that allowing close() above has the same basic effect, //   but we capture that there simply to perform the unbind...",,,unknown,no,0
,//null owner ok??,,,unknown,no,0
,// The name of the SQL function that transforms a string to lowercase,,,unknown,no,0
,"//otherwise return the ""hydrated"" state (ie. associations are not resolved)",,,unknown,no,0
,"// If this from element is a collection and the path is a collection property (maxIndex, etc.) then // generate a sub-query.",,,unknown,no,0
,"//if there is no resulting row, return null",,,unknown,no,0
,"//we must use the ""remembered"" uk value, since it is  //not available from the EntityEntry during assembly",,,unknown,no,0
,"/*ArrayList list = new ArrayList();			list.addAll( getKey().getConstraintColumns() );			list.addAll( getIndex().getConstraintColumns() );			getCollectionTable().createUniqueKey(list);*/",,,unknown,no,0
,"// select topic, syntax from information_schema.help // where section like 'Function%' order by section, topic // // see also ->  http://www.h2database.com/html/functions.html",,,unknown,no,0
,// we have an embedded composite identifier,,,unknown,no,0
,//Must occur after resolving identifiers!,,,unknown,no,0
,"// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",,,unknown,no,0
,// a nested composite element,,,unknown,no,0
,// cache these since they are stateless // this one could even be static...,,,unknown,no,0
,// ALIASES,,,unknown,no,0
,// and perform the load,,,unknown,no,0
,"// an ""embedded"" component (composite ids and unique) // note that this does not handle nested components",,,unknown,no,0
,"// this is a collection initializer, so we must create a collection // for each of the passed-in keys, to account for the possibility // that the collection is empty and has no rows in the result set",,,unknown,no,0
,//this.forceCacheRefresh = forceCacheRefresh;,,,unknown,no,0
,/*(LockMode) anything*/,,,unknown,no,0
,"//Enable for HHH-440, which we don't like:",,,unknown,no,0
,// empty means no scoping,,,unknown,no,0
,// ORPHAN DELETE (used for programmer error detection),,,unknown,no,0
,// now get an existing proxy for each row element (if there is one),,,unknown,no,0
,// performance op to avoid the array search,,,unknown,no,0
,// Custom sql,,,unknown,no,0
,// Create a new FROM node for the referenced class.,,,unknown,no,0
,//stops flush being called multiple times if this method is recursively called,,,unknown,no,0
,"//if there is no property-ref, assume the join //is to the subclass table (ie. the table of the //subclass that the association belongs to)",,,unknown,no,0
,"// if the metadata allowed proxy creation and caller did not request forceful eager loading, // generate a proxy",,,unknown,no,0
,"//strip leading "", """,,,unknown,no,0
,//deliberately ignore return value!,,,unknown,no,0
,"/**	 * Translates an AST join type (i.e., the token type) into a JoinFragment.XXX join type.	 *	 * @param astJoinType The AST join type (from HqlSqlTokenTypes or SqlTokenTypes)	 * @return a JoinFragment.XXX join type.	 * @see JoinFragment	 * @see SqlTokenTypes	 */",,,unknown,no,0
,// The syntax used to add a column to a table,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// model.getKey().setType( new Type( model.getIdentifier() ) );,,,unknown,no,0
,"// cascade first, so that all unsaved objects get their // copy created before we actually copy //cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);",,,unknown,no,0
,// CUSTOM SQL,,,unknown,no,0
,// assume we are in an auto-commit state,,,unknown,no,0
,// temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// the loaded owner will be set to null after the collection is removed, // so capture its value as the affected owner so it is accessible to // both pre- and post- events",,,unknown,no,0
,// dynamic filters attached to the class-level,,,unknown,no,0
,// saveOrUpdateCopy() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// ( (Column) discrim.getColumnIterator().next() ).setType(type);,,,unknown,no,0
,// Inner classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//information about all columns/formulas in class hierarchy,,,unknown,no,0
,"// If there are any scalars (non-entities) selected, render the select column aliases.",,,unknown,no,0
,//information about lazy properties of this class,,,unknown,no,0
,// added this caching as I noticed that getType() is being called multiple times...,,,unknown,no,0
,"// for version properties marked as being generated, make sure they are ""always"" // generated; aka, ""insert"" is invalid; this is dis-allowed by the DTD, // but just to make sure...",,,unknown,no,0
,//pass this as an argument only to avoid double looking,,,unknown,no,0
,// The optional SQL string defined in the where attribute,,,unknown,no,0
,"// simple, because we can't have a one-to-one or a collection  // (or even a property-ref) in a composite-element:",,,unknown,no,0
,// Completely optional cascading drop clause.,,,unknown,no,0
,"// during deserialization, we need to reconnect all proxies and // collections to this session, as well as the EntityEntry and // CollectionEntry instances; these associations are transient // because serialization is used for different things.",,,unknown,no,0
,// SUBCLASS PROPERTY CLOSURE,,,unknown,no,0
,//note early exit here:,,,unknown,no,0
,// replicate does cascade to uninitialized collections,,,unknown,no,0
,// only one-to-one is lazy fetched,,,unknown,no,0
,"// sybase driver (jConnect) throwing NPE here in certain // cases, but we'll just handle the general ""unexpected"" case",,,unknown,no,0
,// Handle any filters applied to the class level,,,unknown,no,0
,"// the configured transaction-factory says it only supports // local callback mode, so no sense attempting to register a // JTA Synchronization",,,unknown,no,0
,//before add :-),,,unknown,no,0
,"// in an effort to avoid concurrent-modification-exceptions (from // potential recursive calls back through here as a result of the // eventual call to PersistentCollection#endRead), we scan the // internal loadingCollections map for matches and store those matches // in a temp collection.  the temp collection is then used to ""drive"" // the #endRead processing.",,,unknown,no,0
,// The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation level,,,unknown,no,0
,// PROPERTIES,,,unknown,no,0
,//WHERE STRING,,,unknown,no,0
,//operations which cascade as far as the collection also cascade to collection elements,,,unknown,no,0
,// VERSION,,,unknown,no,0
,"// We call getKeyFromResultSet() here so that we can know the // key value upon which to perform the breaking logic.  However, // it is also then called from getRowFromResultSet() which is certainly // not the most efficient.  But the call here is needed, and there // currently is no other way without refactoring of the doQuery()/getRowFromResultSet() // methods",,,unknown,no,0
,// IDENTIFIER,,,unknown,no,0
,// potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitly,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//sqlResultTypes = ( Type[] ) sqlResultTypeList.toArray( new Type[sqlResultTypeList.size()] );,,,unknown,no,0
,// the class hierarchy structure,,,unknown,no,0
,//its the given optional object,,,unknown,no,0
,"// aggregate functions shouldn't be registered, right? //registerFunction( ""list"", new StandardSQLFunction(""list"",Hibernate.STRING) ); // stopped on $list",,,unknown,no,0
,"// this is the root (versioned) table, and we are using version-based // optimistic locking;  if we are not updating the version, also don't // check it (unless this is a ""generated"" version column)!",,,unknown,no,0
,"// Use theta style (for regression) // Move the node up, after the origin node.",,,unknown,no,0
,// simple nullability constraint,,,unknown,no,0
,// instantiate a new instance,,,unknown,no,0
,"//starts with 1, implicitly",,,unknown,no,0
,// SUBCLASSES,,,unknown,no,0
,// we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource) // EARLY EXIT!!!!,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// for dialects which are known to not support ANSI-SQL row-value-constructor syntax, // we should mutate the tree.",,,unknown,no,0
,// subclass closure properties,,,unknown,no,0
,"//Cope with special cases of AND, NOT, ()",,,unknown,no,0
,// make it circular-reference safe,,,unknown,no,0
,// return a newly loaded object,,,unknown,no,0
,// Custom sql,,,unknown,no,0
,//skip the FROM keyword in params,,,unknown,no,0
,// This assumes you will want to ignore any update counts ,,,unknown,no,0
,// bit_length feels a bit broken to me. We have to cast to char in order to // pass when a numeric value is supplied. But of course the answers given will // be wildly different for these two datatypes. 1234.5678 will be 9 bytes as // a char string but will be 8 or 16 bytes as a true numeric. // Jay Nance 2006-09-22,,,unknown,no,0
,//add the restriction to the outer select,,,unknown,no,0
,// SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// add the main query,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//we need to upgrade the lock mode to the mode requested,,,unknown,no,0
,//	register the type of the out param - an Oracle specific type,,,unknown,no,0
,// look for a proxy,,,unknown,no,0
,// register resolvers set via Environment property,,,unknown,no,0
,// hibernate impelemnts cast in Dialect.java,,,unknown,no,0
,// assumes that types are all of span 1,,,unknown,no,0
,"//getDefaultProperties().setProperty(Environment.STATEMENT_BATCH_SIZE, NO_BATCH);",,,unknown,no,0
,// ignore it,,,unknown,no,0
,// binary %Stream // character %Stream,,,unknown,no,0
,"// we did not find a collection element in the result set, so we // ensure that a collection is created with the owner's identifier, // since what we have is an empty collection",,,unknown,no,0
,//update all the modified entries,,,unknown,no,0
,"// an existing collection that was either non-empty or uninitialized // is replaced by null or a different collection // (if the collection is uninitialized, hibernate has no way of // knowing if the collection is actually empty without querying the db)",,,unknown,no,0
,// The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.,,,unknown,no,0
,"// features which change between 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~~~~~~~~~",,,unknown,no,0
,//private List aliases = new ArrayList();,,,unknown,no,0
,//Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!,,,unknown,no,0
,// not final-static to avoid possible classcast exceptions if using different oracle drivers.,,,unknown,no,0
,// might happen with a managed connection,,,unknown,no,0
,//( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();,,,unknown,no,0
,"// need to treat this as if it where optimistic-lock=""all"" (dirty does *not* make sense); // first we need to locate the ""loaded"" state // // Note, it potentially could be a proxy, so perform the location the safe way...",,,unknown,no,0
,"// features which remain constant across 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~",,,unknown,no,0
,// evicts don't cascade to uninitialized collections,,,unknown,no,0
,// Multi-param date dialect functions...,,,unknown,no,0
,// Multi-param numeric dialect functions...,,,unknown,no,0
,//tokens that close a sub expression //tokens that open a sub expression //tokens that would indicate a sub expression is a boolean expression,,,unknown,no,0
,// the class hierarchy structure,,,unknown,no,0
,"// we got here because we assumed that an instance // with an assigned id was detached, when it was // really persistent",,,unknown,no,0
,//use suffix for the entity columns,,,unknown,no,0
,// initialize the Set of queried identifier spaces (ie. tables),,,unknown,no,0
,"//			buf.append( selectFragment( lhsAlias, """" ) )//ignore suffix for collection columns!",,,unknown,no,0
,"//registerFunction( ""trim"", new StandardSQLFunction( ""trim"", Hibernate.STRING ) );",,,unknown,no,0
,// update removed rows fks to null,,,unknown,no,0
,"// if the current depth is 0, the root thing being loaded is the // many-to-many collection itself.  Here, it is alright to use // an inner join...",,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitly,,,unknown,no,0
,//identifier collections not supported for 1-to-many,,,unknown,no,0
,"//scan the query string for class names appearing in the from clause and replace //with all persistent implementors of the class/interface, returning multiple //query strings (make sure we don't pick up a class in the select clause!)",,,unknown,no,0
,//==elementType ??,,,unknown,no,0
,//root entity comes *last*,,,unknown,no,0
,// See if the user configured a multiplexer stack,,,unknown,no,0
,// remove the current element from insertions. It will be added back later.,,,unknown,no,0
,//private final String rootTableName;,,,unknown,no,0
,//INITIALIZATION:,,,unknown,no,0
,// the mapping of entity names to their latest batch numbers.,,,unknown,no,0
,// subclass discrimination works by assigning particular // values to certain combinations of null primary key // values in the outer join using an SQL CASE,,,unknown,no,0
,"//expressionTerminators.add("",""); // deliberately excluded",,,unknown,no,0
,// the closure of all properties in the entire hierarchy including // subclasses and superclasses of this class,,,unknown,no,0
,// 23000: Check constraint violation: {0} // 23001: Unique index or primary key violation: {0},,,unknown,no,0
,//INITIALIZATION:,,,unknown,no,0
,// for deprecated saveOrUpdateCopy(),,,unknown,no,0
,"// note that for sequential scrolling, we make the assumption that // the first persister element is the ""root entity""",,,unknown,no,0
,//chop the last union (all),,,unknown,no,0
,// This could also just be true all the time...,,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//sort the updates by fk,,,unknown,no,0
,// Execute the SQL:,,,unknown,no,0
,// Add these directly to the executions queue,,,unknown,no,0
,//disassembled state gets put in a new array (we write to cache by value!),,,unknown,no,0
,// the list of entity names that indicate the batch number,,,unknown,no,0
,// return existing object or initialized proxy (unless deleted),,,unknown,no,0
,// continue loop,,,unknown,no,0
,//not null ... (start with 1) is implicit,,,unknown,no,0
,"//processCollectionProperty(token, q.getCollectionPersister(collectionRole), collectionName);",,,unknown,no,0
,// we already know current is not null...,,,unknown,no,0
,// collections don't dirty an unversioned parent entity,,,unknown,no,0
,// scroll ahead,,,unknown,no,0
,//fetch the generated id in a separate query,,,unknown,no,0
,// prepare and execute the insert,,,unknown,no,0
,"// if everything went ok, commit the transaction and close the obtained // connection handle...",,,unknown,no,0
,// COLUMN(S),,,unknown,no,0
,// prepare and execute the insert,,,unknown,no,0
,// PersistentIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// PROPERTIES,,,unknown,no,0
,// IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//source.getBatcher().executeBatch(); //found another way to ensure that all batched joined inserts have been executed,,,unknown,no,0
,// join.getKey().setType( new Type( lazz.getIdentifier() ) );,,,unknown,no,0
,// table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// TABLENAME,,,unknown,no,0
,"// Identity map of CollectionEntry instances, by the collection wrapper",,,unknown,no,0
,// substitutes into values by side-effect,,,unknown,no,0
,"//source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );",,,unknown,no,0
,//keep the existing version number in the case of replicate!,,,unknown,no,0
,//even process null collections,,,unknown,no,0
,// KEY,,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,// we just hit the last position,,,unknown,no,0
,// scroll backward,,,unknown,no,0
,// KEY,,,unknown,no,0
,// column index,,,unknown,no,0
,// look for the instance by uuid,,,unknown,no,0
,//prevents this session from adding things to cache,,,unknown,no,0
,// this will throw an error if there's something wrong.,,,unknown,no,0
,// Check named HQL queries,,,unknown,no,0
,// EntityNotFoundDelegate,,,unknown,no,0
,//stats,,,unknown,no,0
,//checking for named queries,,,unknown,no,0
,//JNDI + Serialization:,,,unknown,no,0
,// PROPERTIES,,,unknown,no,0
,// cache region is defined by the root-class in the hierarchy...,,,unknown,no,0
,//Generators:,,,unknown,no,0
,// Caches,,,unknown,no,0
,// Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// do this when all the properties are updateable since there is // a certain likelihood that the information will already be // snapshot-cached.,,,unknown,no,0
,//column unique-key,,,unknown,no,0
,// Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// we have not yet hit the last result...,,,unknown,no,0
,// properties,,,unknown,no,0
,// joined subclasses,,,unknown,no,0
,// refer to comment in StatefulPersistenceContext.addCollection(),,,unknown,no,0
,"//throw new IdentifierGenerationException(""save associated object first, or disable cascade for inverse association"");",,,unknown,no,0
,"// so we ""clock over"" on the first invocation",,,unknown,no,0
,//hilo config,,,unknown,no,0
,// DISCRIMINATOR,,,unknown,no,0
,//sql = update;,,,unknown,no,0
,// performance opt,,,unknown,no,0
,//for EJB3,,,unknown,no,0
,//sql = query;,,,unknown,no,0
,//hilo params,,,unknown,no,0
,// AbstractSelectingDelegate impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// uuid.hex is deprecated,,,unknown,no,0
,//handle HQL2 collection syntax,,,unknown,no,0
,//do replacements,,,unknown,no,0
,//ignore whitespace,,,unknown,no,0
,"// ""finish off"" the join",,,unknown,no,0
,"// Object insertions, updates, and deletions have list semantics because // they must happen in the right order so as to respect referential // integrity",,,unknown,no,0
,"// this is either a <version/> tag with no type attribute, // or a <timestamp/> tag",,,unknown,no,0
,// Primary key constraint,,,unknown,no,0
,// DISCRIMINATOR,,,unknown,no,0
,// VERSION / TIMESTAMP,,,unknown,no,0
,"// don't allow comments on these insert statements as comments totally // blow up the Oracle getGeneratedKeys ""support"" :(",,,unknown,no,0
,//count++;,,,unknown,no,0
,// properties,,,unknown,no,0
,"// go ahead and set the lazy here, since pojo.proxy can override it.",,,unknown,no,0
,// get meta's from <subclass>,,,unknown,no,0
,// cascade-save to many-to-one BEFORE the parent is saved,,,unknown,no,0
,// the default...,,,unknown,no,0
,// if the given name is un-qualified we may neen to qualify it,,,unknown,no,0
,"// Loaded entity instances, by EntityKey",,,unknown,no,0
,// CUSTOM SQL,,,unknown,no,0
,// PERSISTER,,,unknown,no,0
,"// Use the delegate, resolve identifiers as FROM element aliases.",,,unknown,no,0
,// do nothing until we hit the rsult set containing the generated id,,,unknown,no,0
,"// so we ""clock over"" on the first invocation",,,unknown,no,0
,//keep the behavior consistent even for boundary usages,,,unknown,no,0
,//first element of array is reserved for the actual instance we are loading!,,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,// OPTIMISTIC LOCK MODE,,,unknown,no,0
,// SELECT BEFORE UPDATE,,,unknown,no,0
,"// we need to dirty check collections, since they can cause an owner // version number increment",,,unknown,no,0
,// BATCH SIZE,,,unknown,no,0
,// IMPORT,,,unknown,no,0
,// DYNAMIC UPDATE,,,unknown,no,0
,//for a dynamic-class,,,unknown,no,0
,//test this entity to see if we must query it,,,unknown,no,0
,//NOTE EARLY EXIT,,,unknown,no,0
,// FieldHandler impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// FieldInterceptor impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// we have a Javassist enhanced entity,,,unknown,no,0
,// we have a Javassist enhanced entity,,,unknown,no,0
,// we have a CGLIB enhanced entity,,,unknown,no,0
,// we have a CGLIB enhanced entity,,,unknown,no,0
,// use old (HB 2.1) defaults if outer-join is specified,,,unknown,no,0
,"//NOTE SPECIAL CASE: // one-to-one constrained=false cannot be proxied, // so default to join and non-lazy",,,unknown,no,0
,// Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// parameter bind values...,,,unknown,no,0
,// the old-time stand-by...,,,unknown,no,0
,// we need to writeObject() on this since interceptor is user defined,,,unknown,no,0
,// ignore this error for now,,,unknown,no,0
,// basically just an adapted copy of find(CriteriaImpl),,,unknown,no,0
,// decode row selection...,,,unknown,no,0
,//stops flush being called multiple times if this method is recursively called,,,unknown,no,0
,"//if it is initialized, see if the underlying //instance is contained, since we need to  //account for the fact that it might have been //evicted",,,unknown,no,0
,// aload_0,,,unknown,no,0
,"// otherwise, we only need to flush if there are in-memory changes // to the queried tables",,,unknown,no,0
,// subclass accesses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// should *not* need to grow beyond the size of the total number of columns in the rs,,,unknown,no,0
,// for backward-compatability,,,unknown,no,0
,"// should probably no-op commit/rollback here, at least in JTA scenarios",,,unknown,no,0
,// not necessarily a *unique* property reference,,,unknown,no,0
,// VERSION UNSAVED-VALUE,,,unknown,no,0
,// ID UNSAVED-VALUE,,,unknown,no,0
,// ResultSet impl (delegated) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// ResultSet impl (""overridden"") ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",,,unknown,no,0
,// EARLY EXIT!!!!,,,unknown,no,0
,"// If we are in the process of releasing, no sense // checking for aggressive-release possibility.",,,unknown,no,0
,// see explanation above...,,,unknown,no,0
,// no big deal,,,unknown,no,0
,// no big deal,,,unknown,no,0
,//no big deal,,,unknown,no,0
,// calls executeBatch(),,,unknown,no,0
,// register synch; stats.connect(),,,unknown,no,0
,// GENERATOR,,,unknown,no,0
,/*package*/,,,unknown,no,0
,// assume we are in an auto-commit state,,,unknown,no,0
,// used from testsuite,,,unknown,no,0
,// explicitly perform no checking...,,,unknown,no,0
,// Various Expectation instances ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// not for internal use:,,,unknown,no,0
,"// if it was previously unreferenced, we need to flush in order to // get its state into the database in order to execute query",,,unknown,no,0
,//only collections belonging to deleted entities are allowed to be dereferenced in the case of orphan delete,,,unknown,no,0
,// for an any // we will have to use reflection,,,unknown,no,0
,// otherwise immediately materialize it,,,unknown,no,0
,"// first, try to load it from the temp PC associated to this SS",,,unknown,no,0
,"//final boolean forceCacheRefresh,",,,unknown,no,0
,// ROLENAME,,,unknown,no,0
,"// the user specifically supplied update=""true"", // which constitutes an illegal combo",,,unknown,no,0
,// updateable only because the user did not specify  // anything; just override it,,,unknown,no,0
,// properties generated on update can never be updateable...,,,unknown,no,0
,// insertable simply because that is the user did not specify // anything; just override it,,,unknown,no,0
,// for an any,,,unknown,no,0
,"// select-range is terminated by declaration of ""from""",,,unknown,no,0
,// loading ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// cache the actual id of the object, not the value of the // property-ref, which might not be initialized",,,unknown,no,0
,// updates ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// deletes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// for each of the defined parameters, make sure its value // has been set",,,unknown,no,0
,// Make sure this is a defined parameter and check the incoming value type,,,unknown,no,0
,// look for existing collection as part of the persistence context,,,unknown,no,0
,"//must add to JNDI _after_ adding to HashMaps, because some JNDI servers use serialization",,,unknown,no,0
,// ignore this error for now,,,unknown,no,0
,/////////////////////////////////////////////////////////////////////////////////////////////////////,,,unknown,no,0
,// no auto-flushing to support in stateless session,,,unknown,no,0
,// FETCH STRATEGY,,,unknown,no,0
,// refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// ignore,,,unknown,no,0
,//do not return a proxy! //(this option indicates we are initializing a proxy),,,unknown,no,0
,// this is an internal error of some sort...,,,unknown,no,0
,// do not auto-flush while outside a transaction,,,unknown,no,0
,// set up second pass,,,unknown,no,0
,// replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// unsorted, natural, comparator.class.name",,,unknown,no,0
,// CUSTOM SQL,,,unknown,no,0
,// load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// TABLE,,,unknown,no,0
,// delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// SORT,,,unknown,no,0
,"//after setting values to object, entityMode",,,unknown,no,0
,//handle quoted strings,,,unknown,no,0
,"//allow ODMG OQL style: from Person p, p.cars c",,,unknown,no,0
,// ID,,,unknown,no,0
,// invokeinterface // enabled.getInterceptFieldCallback(),,,unknown,no,0
,//crossJoins.add(name);,,,unknown,no,0
,// checkcast,,,unknown,no,0
,// checkcast,,,unknown,no,0
,"//following doesn't handle (null, not null) but unnecessary //since this would mean all rows",,,unknown,no,0
,// dup,,,unknown,no,0
,//.getElementPropertyMapping();,,,unknown,no,0
,"// The keyword used to specify an identity column, if identity column key generation is supported.",,,unknown,no,0
,// return,,,unknown,no,0
,// just do the regular thing if you can't find the ctor // Your AST must have default ctor to use this.,,,unknown,no,0
,//register collection role,,,unknown,no,0
,// int,,,unknown,no,0
,// return aliases not supported in classic translator!,,,unknown,no,0
,"// SELECT p FROM p IN CLASS eg.Person GROUP BY p.Name, p.Address, p",,,unknown,no,0
,//this is basically a copy/paste of OrderByParser ... might be worth refactoring,,,unknown,no,0
,// the name of an SQL function,,,unknown,no,0
,//special case,,,unknown,no,0
,// invokeinterface // invoke Callback.read*() // each type,,,unknown,no,0
,"//if we are inside a new Result(), but not inside a nested function",,,unknown,no,0
,//opening paren in new Foo ( ... ),,,unknown,no,0
,//ie no select clause in HQL,,,unknown,no,0
,// invokeinterface // enabled.getInterceptFieldCallback(),,,unknown,no,0
,// double,,,unknown,no,0
,// ifnonnull (label1),,,unknown,no,0
,// short,,,unknown,no,0
,// char,,,unknown,no,0
,// boolean,,,unknown,no,0
,"//q.addCollection(collectionName, collectionRole);",,,unknown,no,0
,// array of reference type,,,unknown,no,0
,// not array,,,unknown,no,0
,// reference type,,,unknown,no,0
,//many-to-many,,,unknown,no,0
,"// return the concrete type, or the underlying type if a concrete type // was not specified",,,unknown,no,0
,// reference type,,,unknown,no,0
,// getfield // old value of the field,,,unknown,no,0
,// ldc // field name,,,unknown,no,0
,// return ;,,,unknown,no,0
,//there _was_ a select clause,,,unknown,no,0
,// putfield,,,unknown,no,0
,//ie. no select clause,,,unknown,no,0
,// *load_1,,,unknown,no,0
,// *load_1,,,unknown,no,0
,// we are the LHS of the DOT representing a naked comp-prop-ref,,,unknown,no,0
,// ldc // name of the field,,,unknown,no,0
,//many-to-many,,,unknown,no,0
,// *store_1 // each type,,,unknown,no,0
,// *return // each type,,,unknown,no,0
,// aload 5 // load exception,,,unknown,no,0
,// astore 5 // store exception,,,unknown,no,0
,/* local variables | target obj | each oldvalue | */,,,unknown,no,0
,// dotcount>=2,,,unknown,no,0
,// checkcast,,,unknown,no,0
,// invokevirtual,,,unknown,no,0
,// return,,,unknown,no,0
,// return,,,unknown,no,0
,// aload_0,,,unknown,no,0
,// Following methods we don't delegate since they have so little logic // it's clearer to just implement them here,,,unknown,no,0
,//after reset!,,,unknown,no,0
,// aload_0,,,unknown,no,0
,//reset the dotcount (but not the path) //after reset!,,,unknown,no,0
,// Private constructor - stops checkstyle from complaining.,,,unknown,no,0
,// register in exception table,,,unknown,no,0
,// end region to handling exception (BulkAccessorException),,,unknown,no,0
,"// at some point the processing went bad, so we need to: //      1) make sure the connection handle gets released //      2) try to cleanup the JTA context as much as possible",,,unknown,no,0
,/* current stack len = 2 */,,,unknown,no,0
,// checkcast (case of reference type),,,unknown,no,0
,/* | this | bean | args | raw bean | */,,,unknown,no,0
,// iload_3 // i,,,unknown,no,0
,// Do the corresponding RHS,,,unknown,no,0
,// aload_0 // load this,,,unknown,no,0
,// *return // each type,,,unknown,no,0
,// ifnonnull,,,unknown,no,0
,// invokeinterface // invoke Enabled.getInterceptFieldCallback(),,,unknown,no,0
,// getfield // get each field,,,unknown,no,0
,// log a message about potential connection leaks,,,unknown,no,0
,// case of non-static field,,,unknown,no,0
,// aload_1 // load callback,,,unknown,no,0
,// aload_0 // load this,,,unknown,no,0
,// an association,,,unknown,no,0
,// invokespecial // BulkAccessorException.<init>,,,unknown,no,0
,//important!!,,,unknown,no,0
,/* local variable | this | */,,,unknown,no,0
,//join = q.createJoinFragment(useThetaStyleJoin);,,,unknown,no,0
,//or its the id property name,,,unknown,no,0
,//swallow,,,unknown,no,0
,"//if its ""id""",,,unknown,no,0
,// WARNING: classfile only,,,unknown,no,0
,// athrow,,,unknown,no,0
,// classic parser does not support bulk manipulation statements,,,unknown,no,0
,// aload_0,,,unknown,no,0
,// starts with a path expression (new style),,,unknown,no,0
,"// just decrement the lock, don't recache // (we don't know which transaction won)",,,unknown,no,0
,//path expression,,,unknown,no,0
,// get meta's from <class>,,,unknown,no,0
,//named query parameter,,,unknown,no,0
,// Add any joins,,,unknown,no,0
,// the next one up must also be,,,unknown,no,0
,"//Cope with special cases of AND, NOT, )",,,unknown,no,0
,//Open any extra brackets we might need.,,,unknown,no,0
,"//process a token, mapping OO path expressions to SQL expressions",,,unknown,no,0
,"// again, CCS did not have such a concept; however a reasonable // proximity is to clear the cache.  For non-transaction aware // caches, we will also do a clear at the end of the transaction",,,unknown,no,0
,// assumes that types are all of span 1,,,unknown,no,0
,// no-op; CCS did not have such a concept,,,unknown,no,0
,// JoinProcessor needs to know if the where clause fragment came from a dynamic filter or not so it // can put the where clause fragment in the right place in the SQL AST.   'hasFilterCondition' keeps track // of that fact.,,,unknown,no,0
,// no-op; CCS did not have such a concept,,,unknown,no,0
,"//persister.setIdentifier(result, id); //before calling interceptor, for consistency with normal load",,,unknown,no,0
,//take note when this is a boolean expression,,,unknown,no,0
,//Close extra brackets we opened,,,unknown,no,0
,// use the id value of a newly instantiated instance as the unsaved-value,,,unknown,no,0
,//Cope with a subselect,,,unknown,no,0
,//NOTE: early return,,,unknown,no,0
,// DB-OBJECTNAME,,,unknown,no,0
,// saves / updates don't cascade to uninitialized collections,,,unknown,no,0
,// float,,,unknown,no,0
,// MUTABLE,,,unknown,no,0
,// treat it as a path expression,,,unknown,no,0
,// treat it as a classname,,,unknown,no,0
,"// process the ""old"" HQL style where aliases appear _first_ // ie. using the IN or IN CLASS constructions",,,unknown,no,0
,// now anything that is not a HQL keyword,,,unknown,no,0
,// 'outer' is optional and is ignored,,,unknown,no,0
,// inner joins can be abbreviated to 'join',,,unknown,no,0
,// start by looking for HQL keywords...,,,unknown,no,0
,//cannot instantiate,,,unknown,no,0
,"//NOTICE: no "" or . since they are part of (compound) identifiers",,,unknown,no,0
,"// ""finish off"" the join",,,unknown,no,0
,// the path expression ends at the ],,,unknown,no,0
,// careful with this!,,,unknown,no,0
,// the path expression continues after a ],,,unknown,no,0
,//anything else,,,unknown,no,0
,// persists don't cascade to uninitialized collections,,,unknown,no,0
,"// properties that we have tried to load, and not found in the database",,,unknown,no,0
,// POLYMORPHISM,,,unknown,no,0
,// WHERE,,,unknown,no,0
,"// A container for collections we load up when the owning entity is not // yet loaded ... for now, this is purely transient!",,,unknown,no,0
,//Cope with a continued path expression (ie. ].baz),,,unknown,no,0
,"//Cope with [,]",,,unknown,no,0
,//ie. a many-to-many,,,unknown,no,0
,//were an odd or even number of NOTs encountered //the join string built up by compound paths inside this expression //a flag indicating if the subexpression is known to be boolean,,,unknown,no,0
,// float,,,unknown,no,0
,// float,,,unknown,no,0
,// double,,,unknown,no,0
,"//Need this, since join condition can appear inside parens!",,,unknown,no,0
,// not known!,,,unknown,no,0
,// reference type,,,unknown,no,0
,// not known!,,,unknown,no,0
,"// boolean, byte, char, int, short",,,unknown,no,0
,// not known!,,,unknown,no,0
,"// boolean, byte, char, int, short",,,unknown,no,0
,// not known!,,,unknown,no,0
,// bad type,,,unknown,no,0
,// bad type,,,unknown,no,0
,// long,,,unknown,no,0
,// This is the legacy behaviour for HQL queries...,,,unknown,no,0
,// can't cache this stuff either (per-invocation),,,unknown,no,0
,// long,,,unknown,no,0
,// This is called when it's time to fully resolve a path expression.,,,unknown,no,0
,// float,,,unknown,no,0
,// bad type,,,unknown,no,0
,// bad type,,,unknown,no,0
,"// boolean, byte, char, int, short",,,unknown,no,0
,//ie. 60 seconds,,,unknown,no,0
,//Inside a BETWEEN ... AND ... expression,,,unknown,no,0
,// TABLE,,,unknown,no,0
,// Do nothing; subclasses may override.,,,unknown,no,0
,// Do nothing; subclasses may override.,,,unknown,no,0
,// this is called from SettingsFactory irregardless; trivial to simply disregard,,,unknown,no,0
,//noop,,,unknown,no,0
,//noop,,,unknown,no,0
,// noop,,,unknown,no,0
,// disassemble positional parameters,,,unknown,no,0
,"//expressionOpeners.add("",""); // deliberately excluded",,,unknown,no,0
,"// the user provided resulttransformer, not the one used with ""select new"". Here to avoid mangling // transformed/non-transformed results.",,,unknown,no,0
,"//by requiring <, we rely on lock timeout in the case of an unsuccessful update!",,,unknown,no,0
,//null clientLock is remotely possible but will never happen in practice,,,unknown,no,0
,// noop,,,unknown,no,0
,//recache the updated state,,,unknown,no,0
,//decrement the lock,,,unknown,no,0
,//Mainly for OSCache,,,unknown,no,0
,// skip finalize methods,,,unknown,no,0
,// Bind the where,,,unknown,no,0
,// ConnectionManager.Callback implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// checkcast,,,unknown,no,0
,//usually useless,,,unknown,no,0
,// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Prepare the left hand side and get the data type.,,,unknown,no,0
,// ignore (probably H2 not in the classpath),,,unknown,no,0
,// HHH-2300,,,unknown,no,0
,// seems to have spotty LOB suppport,,,unknown,no,0
,// Register the type of the out param - PostgreSQL uses Types.OTHER,,,unknown,no,0
,// ALL OTHER,,,unknown,no,0
,// NOT NULL VIOLATION,,,unknown,no,0
,// to support dialects that have their own identity data type,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//deduplicate unique constraints sharing the same columns //this is needed by Hibernate Annotations since it creates automagically // unique constraints for the user,,,unknown,no,0
,// FOREIGN KEY VIOLATION,,,unknown,no,0
,// UNIQUE VIOLATION,,,unknown,no,0
,// CHECK VIOLATION,,,unknown,no,0
,//trim off the length/precision/scale,,,unknown,no,0
,// -- Implementation private methods --,,,unknown,no,0
,"//"" cascade"";",,,unknown,no,0
,"//starts with 1, implicitly",,,unknown,no,0
,"// Oracle8 and previous define only a ""DATE"" type which //      is used to represent all aspects of date/time",,,unknown,no,0
,//used also for generation of FK names!,,,unknown,no,0
,//do not add unique constraint on DB not supporting unique and nullable columns,,,unknown,no,0
,"//NONE, because its the requested lock mode, not the actual! ",,,unknown,no,0
,"//for backward compatibility, disable this:",,,unknown,no,0
,"// Original Dialect.java returns "" for update"";",,,unknown,no,0
,//Primary key constraint,,,unknown,no,0
,// Custom SQL,,,unknown,no,0
,// Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,/* current stack len = 0 */,,,unknown,no,0
,"//an identifier mapper => getKey will be included in the getNonDuplicatedPropertyIterator() //and checked later, so it needs to be excluded",,,unknown,no,0
,//flat recursive algorithm,,,unknown,no,0
,// The RDMS concat() function only supports 2 parameters,,,unknown,no,0
,// nothing to do in a stateful session,,,unknown,no,0
,// Display the dialect version.,,,unknown,no,0
,// not null is implicit,,,unknown,no,0
,// System Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Time and Date Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// ignore it...,,,unknown,no,0
,//Primary key constraint,,,unknown,no,0
,// Custom SQL,,,unknown,no,0
,// may be final,,,unknown,no,0
,//may be final,,,unknown,no,0
,//may be final //may be final //may be final,,,unknown,no,0
,// --- Query translator methods ---,,,unknown,no,0
,"// here assume SQLServer2005 using snapshot isolation, which does not have this problem",,,unknown,no,0
,// Bind the order-by,,,unknown,no,0
,//because numeric can be anything,,,unknown,no,0
,"//pre H3.2 behavior: super.getReturnType(ct, m);",,,unknown,no,0
,// build the map of standard ANSI SQL aggregation functions ~~~~~~~~~~~~~~~,,,unknown,no,0
,"// strip table-owner because Informix always returns constraint names as ""<table-owner>.<constraint-name>""",,,unknown,no,0
,// (NOT (GT a b) ) => (LE a b),,,unknown,no,0
,// Informix doesn't have a bit type,,,unknown,no,0
,//refresh() does not pass an entityName,,,unknown,no,0
,// the standard SQL function name is current_timestamp...,,,unknown,no,0
,// Oracle did add support for ANSI CASE statements in 9i,,,unknown,no,0
,//String[] keyCols = collPersister.getKeyColumnNames();,,,unknown,no,0
,/* current stack len = 0 */,,,unknown,no,0
,// grrr... for differentiation of mysql storage engines,,,unknown,no,0
,"// not so sure this is even valid subtree.  but if it was, it'd // represent two unrelated table references...",,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// astore 4 // store the raw bean,,,unknown,no,0
,// make a new one,,,unknown,no,0
,// NOT_SUPPORTED_SHOULD_USE_JDBC3_PreparedStatement.getGeneratedKeys_method,,,unknown,no,0
,// we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource),,,unknown,no,0
,"//by default, natural-ids are ""immutable"" (constant)",,,unknown,no,0
,"//always do an INSERT, and let it fail by constraint violation",,,unknown,no,0
,// finally use the sqltype if == on Hibernate types did not find a match.,,,unknown,no,0
,// constructors and factory methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// (NOT (IS_NULL a b) ) => (IS_NOT_NULL a b),,,unknown,no,0
,// standard sql92 functions (can be overridden by subclasses),,,unknown,no,0
,// -- Loader overrides --,,,unknown,no,0
,// -- Loader implementation --,,,unknown,no,0
,// This is now handled earlier in this method.,,,unknown,no,0
,//by default,,,unknown,no,0
,// identifier quoting support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// by default we report no support for NOWAIT lock semantics,,,unknown,no,0
,//sqlResultTypes = selectClause.getSqlResultTypes();,,,unknown,no,0
,// by default we report no support,,,unknown,no,0
,// limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// native identifier generatiion ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//private Type[] sqlResultTypes;,,,unknown,no,0
,// database type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//map second/minute/hour/day/month/year to ANSI extract(), override on subclasses",,,unknown,no,0
,//pass the column name (a generated id almost always has a single column),,,unknown,no,0
,//needed to satisfy KeyValue,,,unknown,no,0
,// Verify the state of this new method in Hibernate 3.0 Dialect.java,,,unknown,no,0
,// INDEX AND ROW SELECT,,,unknown,no,0
,//no pointbase TINYINT,,,unknown,no,0
,//no pointbase BIT,,,unknown,no,0
,"/*		 * We might want a special case for 19,2. This is very common for money types		 * and here it is converted to 18,1		 */",,,unknown,no,0
,//ELEMENT,,,unknown,no,0
,// No batch statements,,,unknown,no,0
,// Tell hibernate to use getBytes instead of getBinaryStream,,,unknown,no,0
,"// If we've been blocking for the mutex, perhaps another // thread has already reestablished the root. // In case the node was reestablised via replication, confirm it's  // marked ""resident"" (a status which doesn't replicate)",,,unknown,no,0
,// IBID for current_time and current_date,,,unknown,no,0
,//registerColumnType data types,,,unknown,no,0
,// dynamic filters for the collection,,,unknown,no,0
,// dynamic filters specifically for many-to-many inside the collection,,,unknown,no,0
,"//		return ""select CURRENT_TIMESTAMP from RDB$DATABASE"";",,,unknown,no,0
,//private final String unquotedIdentifierColumnName;,,,unknown,no,0
,// custom sql,,,unknown,no,0
,// sql server just returns automatically,,,unknown,no,0
,//types,,,unknown,no,0
,//extra information about the element type,,,unknown,no,0
,//SQL statements,,,unknown,no,0
,//public boolean isSubselectLoadable();,,,unknown,no,0
,// NativeSQL: collect element column and auto-aliases,,,unknown,no,0
,"//starts with 1, implicitly",,,unknown,no,0
,// Origial Dialect.java returns true;,,,unknown,no,0
,// NativeSQL: collect index column and auto-aliases,,,unknown,no,0
,/*&& !indexIsFormula*/,,,unknown,no,0
,/*&& !indexIsFormula*/,,,unknown,no,0
,//create all the new entries,,,unknown,no,0
,/* local variables | target obj | each oldvalue | */,,,unknown,no,0
,//an assertion,,,unknown,no,0
,//		 This assumes you will want to ignore any update counts,,,unknown,no,0
,// ignore,,,unknown,no,0
,"// We could register the session against the transaction even though it is // not started, but we'd have no guarentee of ever getting the map // entries cleaned up (aside from spawning threads).",,,unknown,no,0
,// Run a subquery loader,,,unknown,no,0
,"//strip leading ','",,,unknown,no,0
,// Take care of any entities that might have // been evicted!	,,,unknown,no,0
,// Handle any filters applied to this collection for many-to-many,,,unknown,no,0
,//not all classpersisters implement PropertyMapping!,,,unknown,no,0
,/* package-private */,,,unknown,no,0
,//GENERATE THE SQL:,,,unknown,no,0
,"//starts with 1, implicitly",,,unknown,no,0
,"//		registerColumnType( Types.VARCHAR, 16777215, ""mediumtext"" ); //		registerColumnType( Types.VARCHAR, 65535, ""text"" );",,,unknown,no,0
,"//		registerColumnType( Types.CLOB, 16777215, ""mediumtext"" ); //		registerColumnType( Types.CLOB, 65535, ""text"" );",,,unknown,no,0
,"// here assume SQLServer2005 using snapshot isolation, which does not have this problem",,,unknown,no,0
,"//strip leading ','",,,unknown,no,0
,//instanceof AssociationType;,,,unknown,no,0
,//		return !isOneToMany();,,,unknown,no,0
,/*&& !indexIsFormula*/,,,unknown,no,0
,// HSQLDB only supports READ_UNCOMMITTED transaction isolation,,,unknown,no,0
,//columnUpdateability.length==0 ||,,,unknown,no,0
,"// this assumes schema support, which is present in 1.8.0 and later...",,,unknown,no,0
,//not null is implicit,,,unknown,no,0
,// function templates,,,unknown,no,0
,// Multi-param dialect functions...,,,unknown,no,0
,// RDMS supports the UNION ALL clause.,,,unknown,no,0
,// the object is persistent,,,unknown,no,0
,// the case of a foreign key to something other than the pk is handled in createPropertyRefConstraints,,,unknown,no,0
,// no foreign key element of for a one-to-many,,,unknown,no,0
,// Used with DROP TABLE to delete all records in the table.,,,unknown,no,0
,"//starts with 1, implicitly",,,unknown,no,0
,// },,,unknown,no,0
,// *** Sequence methods - end,,,unknown,no,0
,"// don't create a unique key, 'cos some // databases don't like a UK on nullable // columns",,,unknown,no,0
,"//if it is a formula index, use the element columns in the PK",,,unknown,no,0
,// methods to make it possible to use the Native Id generator,,,unknown,no,0
,// *** Sequence methods - start. The RDMS dialect needs these,,,unknown,no,0
,// index should be last column listed,,,unknown,no,0
,"//the entity is associated with the session, so check its status",,,unknown,no,0
,// Multi-param string dialect functions...,,,unknown,no,0
,// Multi-param numeric dialect functions...,,,unknown,no,0
,// iterate entries ordered by capacity to find first fit,,,unknown,no,0
,//return memberPersister.getType();,,,unknown,no,0
,"//return memberPersister.toColumns(alias, propertyName);",,,unknown,no,0
,//return memberPersister.getPropertyType(propertyName);,,,unknown,no,0
,//},,,unknown,no,0
,//},,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// expected type is intrinsic here...,,,unknown,no,0
,// add new ordered map,,,unknown,no,0
,"// TimesTen has no known variation of a ""SELECT ... FOR UPDATE"" syntax...",,,unknown,no,0
,// Multi-param date dialect functions...,,,unknown,no,0
,"/*public boolean supportsForUpdateNowait() {		return false;	}*/",,,unknown,no,0
,// new methods in dialect3,,,unknown,no,0
,"// TimesTen has no BLOB/CLOB support, but these types may be suitable  // for some applications. The length is limited to 4 million bytes.",,,unknown,no,0
,//	register the type of the out param - an Oracle specific type,,,unknown,no,0
,// return,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// simple nullability constraint,,,unknown,no,0
,//$NON-NLS-1,,,unknown,no,0
,"//pull off the last "", """,,,unknown,no,0
,// This is called when it's time to fully resolve a path expression.,,,unknown,no,0
,"//if we only returned one entity, query by key is more efficient",,,unknown,no,0
,// First we need to suspend any current JTA transaction and obtain // a JDBC connection,,,unknown,no,0
,// any earlier proxy takes precedence,,,unknown,no,0
,//EARLY EXIT!,,,unknown,no,0
,"//needed for SOAP libraries, etc",,,unknown,no,0
,//element = XMLHelper.generateDom4jElement( persister.getNodeName() );,,,unknown,no,0
,//can't reuse in this case,,,unknown,no,0
,//orphan delete not supported for EntityMode.DOM4J,,,unknown,no,0
,//we can reuse it for each row,,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,//element = XMLHelper.generateDom4jElement( persister.getNodeName() );,,,unknown,no,0
,//orphan delete not supported for EntityMode.DOM4J,,,unknown,no,0
,//Set USE_REFLECTION_OPTIMIZER to false to fix HHH-227,,,unknown,no,0
,"//end of array, start filling again from start",,,unknown,no,0
,// invokeinterface,,,unknown,no,0
,"//<String, String>",,,unknown,no,0
,"//<String, String>",,,unknown,no,0
,//	private final List extendsQueue;,,,unknown,no,0
,"//final String queryString, ",,,unknown,no,0
,//		settings.setComponentTuplizerFactory( this.getComponentTuplizerFactory() );,,,unknown,no,0
,//getResultList(results);,,,unknown,no,0
,// the element has been removed from the set,,,unknown,no,0
,// here we do not bother with the discriminator.,,,unknown,no,0
,// the element has changed,,,unknown,no,0
,"//needed for SOAP libraries, etc",,,unknown,no,0
,// else this is not a collection initializer (and empty collections will // be detected by looking for the owner's identifier in the result set),,,unknown,no,0
,//handle empty collections,,,unknown,no,0
,// handle empty collection,,,unknown,no,0
,// a collection loaded in the current session // can not possibly be the collection belonging // to the entity passed to update(),,,unknown,no,0
,// this is the regression style determination which matches the logic of the classic translator,,,unknown,no,0
,//write(); -- doesn't,,,unknown,no,0
,//write(); -- doesn't,,,unknown,no,0
,"// a many-to-many; // decrement currentDepth here to allow join across the association table // without exceeding MAX_FETCH_DEPTH (i.e. the ""currentDepth - 1"" bit)",,,unknown,no,0
,/*(array==null) ? tempList.get(i) :*/,,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,// iterate over the *old* list,,,unknown,no,0
,// collect EntityIdentifier(s) of the *current* elements - add them into a HashSet for fast access,,,unknown,no,0
,//do this bit after setting initialized to true or it will recurse,,,unknown,no,0
,//override on some subclasses,,,unknown,no,0
,// override on some subclasses,,,unknown,no,0
,//needed so that we remove this collection from the second-level cache,,,unknown,no,0
,//Careful: these methods do not initialize the collection.,,,unknown,no,0
,// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// found,,,unknown,no,0
,// found,,,unknown,no,0
,//		Iterator iter = extendsQueue.iterator();,,,unknown,no,0
,//			Iterator iterator = extendsQueue.iterator();,,,unknown,no,0
,// cannot handle single quotes,,,unknown,no,0
,//		settings.setFormatSqlEnabled(formatSql);,,,unknown,no,0
,//postInitialize() will be called after initialization,,,unknown,no,0
,//		settings.setShowSqlEnabled(showSql);,,,unknown,no,0
,//Statistics and logging:,,,unknown,no,0
,//SQL Exception converter:,,,unknown,no,0
,// Second-level / query cache:,,,unknown,no,0
,//Query parser settings:,,,unknown,no,0
,//SQL Generation settings:,,,unknown,no,0
,// Transaction settings:,,,unknown,no,0
,// user supplied JDBC connections,,,unknown,no,0
,//Interrogate JDBC metadata,,,unknown,no,0
,//JDBC and connection settings:,,,unknown,no,0
,//JDBC and connection settings:,,,unknown,no,0
,//SessionFactory name:,,,unknown,no,0
,"// first, iterate over all elements capable of defining an extends attribute // collecting all found extends references if they cannot be resolved // against the already processed mappings.",,,unknown,no,0
,// overriding inherited meta attribute. HBX-621 & HBX-793			,,,unknown,no,0
,// Bind the filters,,,unknown,no,0
,"// we already have a callback registered; either a local // (org.hibernate.Transaction) transaction has accepted // callback responsibilities, or we have previously // registered a transaction synch.",,,unknown,no,0
,//Schema export:,,,unknown,no,0
,//if dotted and not load-collection nor return-join //regular property,,,unknown,no,0
,// don't even bother trying to read further,,,unknown,no,0
,"// if doc is null, then for whatever reason, the cached file cannot be used...",,,unknown,no,0
,"//if null, owner will be retrieved from session",,,unknown,no,0
,// this is equivalent to the old behavior...,,,unknown,no,0
,// force the proxy to resolve itself,,,unknown,no,0
,// This method may be called many times!!,,,unknown,no,0
,"// Finally, read ahead one row to position result set cursor // at the first physical row we are interested in loading",,,unknown,no,0
,// Read backwards until we read past the first physical sequential // row with the key we are interested in loading,,,unknown,no,0
,"// sequentially read the result set in reverse until we recognize // a change in the key value.  At that point, we are pointed at // the last physical sequential row for the logical row in which // we are interested in processing",,,unknown,no,0
,// position cursor to the last row,,,unknown,no,0
,//		componentTuplizerFactory = new ComponentTuplizerFactory();,,,unknown,no,0
,//	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907 //	private BytecodeProvider bytecodeProvider;,,,unknown,no,0
,//		extendsQueue = new ArrayList();,,,unknown,no,0
,//	protected List extendsQueue;,,,unknown,no,0
,// using local since the inheritedMetas at this point is not the correct map since it is always the empty map,,,unknown,no,0
,//	public BytecodeProvider getBytecodeProvider() { //		return bytecodeProvider; //	} // //	void setBytecodeProvider(BytecodeProvider bytecodeProvider) { //		this.bytecodeProvider = bytecodeProvider; //	},,,unknown,no,0
,// package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//	public ComponentTuplizerFactory getComponentTuplizerFactory() { //		return componentTuplizerFactory; //	},,,unknown,no,0
,// generated properties can *never* be insertable...,,,unknown,no,0
,// public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// finally, what it's all about...",,,unknown,no,0
,// validate() instances of Validatable,,,unknown,no,0
,//cannot be instantiated,,,unknown,no,0
,"// if debug level is enabled, then log the password, otherwise mask it",,,unknown,no,0
,//inject the data,,,unknown,no,0
,// cannot be instantiated,,,unknown,no,0
,// from SortedMap,,,unknown,no,0
,// from Map,,,unknown,no,0
,"//needed for SOAP libraries, etc",,,unknown,no,0
,"//needed for SOAP libraries, etc",,,unknown,no,0
,//			collectionOwnerAliases.add( ownerAlias );,,,unknown,no,0
,"// If this return's alias has not been processed yet, do so b4 further processing of this return",,,unknown,no,0
,//		scalarColumnAliases.add( typeReturn.getColumnAlias() ); //		scalarTypes.add( typeReturn.getType() );,,,unknown,no,0
,// Make sure the owner alias is known...,,,unknown,no,0
,// already been processed...,,,unknown,no,0
,// already been processed...,,,unknown,no,0
,"// Now, process the returns",,,unknown,no,0
,//	private final List scalarTypes = new ArrayList(); //	private final List scalarColumnAliases = new ArrayList();,,,unknown,no,0
,//NOTE: EARLY EXIT!,,,unknown,no,0
,/*package*/,,,unknown,no,0
,// it is a property reference {foo.bar},,,unknown,no,0
,// The current alias is referencing the collection to be eagerly fetched,,,unknown,no,0
,// passing through anything we do not know : to support jdbc escape sequences HB-898,,,unknown,no,0
,//default pool size 20,,,unknown,no,0
,// register a cleanup synch,,,unknown,no,0
,//null version means the object is in the process of being loaded somewhere else in the ResultSet,,,unknown,no,0
,// wrap the session in the transaction-protection proxy,,,unknown,no,0
,// currently only the Hibernate-supplied DbTimestampType is supported here,,,unknown,no,0
,"// if not a composite key, use ""foo in (?, ?, ?)"" for batching // if no batch, and not a composite key, use ""foo = ?""",,,unknown,no,0
,//unsupported,,,unknown,no,0
,//unsupported,,,unknown,no,0
,"//"" collection_ where "" +",,,unknown,no,0
,"//String[] fk = StringHelper.qualify( ""collection_"", cp.getKeyColumnNames() );",,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,//private String propertyName;,,,unknown,no,0
,//cannot be instantiated,,,unknown,no,0
,// Initialize the error handling delegate.,,,unknown,no,0
,"// Handle collection-fiter compilation. // IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!",,,unknown,no,0
,//EARLY EXIT,,,unknown,no,0
,"// this is the second pass through on a merge op, so here we limit the // replacement to associations types (value types were already replaced // during the first pass)",,,unknown,no,0
,// add temp entry so that the next step is circular-reference // safe - only needed because some types don't take proper // advantage of two-phase-load (esp. components),,,unknown,no,0
,// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// allow these (deprecated) methods to pass through,,,unknown,no,0
,// limit the methods available if no transaction is active,,,unknown,no,0
,// this property belongs on the table and is to be inserted,,,unknown,no,0
,// then bind it,,,unknown,no,0
,// passing through anything we do not know : to support jdbc escape sequences HB-898,,,unknown,no,0
,// it is a simple table alias {foo},,,unknown,no,0
,//pad with nulls from the current last element up to the new index,,,unknown,no,0
,// apend everything up until the next encountered open brace,,,unknown,no,0
,// Let return-propertys override whatever the persister has for aliases.,,,unknown,no,0
,"//the user visible aliases, which are unknown to the superclass, //these are not the actual ""physical"" SQL aliases",,,unknown,no,0
,"//NOTE: unlike all other Loaders, this one is NOT //      multithreaded, or cacheable!!",,,unknown,no,0
,//disable a join back to this same association,,,unknown,no,0
,//we can use an inner join for the many-to-many,,,unknown,no,0
,// we found it,,,unknown,no,0
,// belong to other persister // belong to other persister,,,unknown,no,0
,"// Collection wrappers, by the CollectionKey //key=CollectionKey, value=PersistentCollection",,,unknown,no,0
,/*&& etype.isReferenceToPrimaryKey()*/,,,unknown,no,0
,// needed later for many-to-many/filter application,,,unknown,no,0
,//it must be a collection fetch,,,unknown,no,0
,"// if no batch, use ""foo = ? and bar = ?""",,,unknown,no,0
,//a composite key,,,unknown,no,0
,//search for it //note that this code is incorrect for other than one-to-many,,,unknown,no,0
,//a shortcut if its location didn't change!,,,unknown,no,0
,"// Anyway, here we implement <set> semantics for a // <one-to-many> <bag>!",,,unknown,no,0
,// The property is a collection...,,,unknown,no,0
,//use the id passed in,,,unknown,no,0
,//problematic for <key-many-to-one>!,,,unknown,no,0
,//alias may be null //EARLY EXIT,,,unknown,no,0
,// if it is a compound path,,,unknown,no,0
,"// if its the root criteria, we are done",,,unknown,no,0
,"//it does not refer to an alias of a projection, //look for a property",,,unknown,no,0
,"// No additional open braces found in the string, append the // rest of the string in its entirty and quit this loop",,,unknown,no,0
,// replace {....} with corresponding column aliases,,,unknown,no,0
,// determine if the collection elements are entities...,,,unknown,no,0
,//	private final String[] sqlAliases; //	private final String[] sqlAliasSuffixes;,,,unknown,no,0
,// List OPERATIONS:,,,unknown,no,0
,"// Currently *not* cachable if autodiscover types is in effect (e.g. ""select * ..."")",,,unknown,no,0
,"// Otherwise, this is an ordinary value.",,,unknown,no,0
,//search for it //note that this code is incorrect for other than one-to-many,,,unknown,no,0
,// and the qualifier is not the alias of this criteria //      -> check to see if we belong to some criteria other //          than the one that created us,,,unknown,no,0
,"// otherwise, recurse",,,unknown,no,0
,"//needed for SOAP libraries, etc",,,unknown,no,0
,// Convert the string value into the proper type.,,,unknown,no,0
,"//should never happen, i think",,,unknown,no,0
,//it refers to an alias of a projection,,,unknown,no,0
,"//not found in inner query , try the outer query",,,unknown,no,0
,"//not found in inner query , try the outer query",,,unknown,no,0
,// the entity name,,,unknown,no,0
,//the criteria instance,,,unknown,no,0
,//default mode,,,unknown,no,0
,// aaload,,,unknown,no,0
,// return false;,,,unknown,no,0
,// Generate an explicit join for the root dot node.   The implied joins will be collected and passed up // to the root dot node.,,,unknown,no,0
,//return a proxy if appropriate,,,unknown,no,0
,"// should be the first, but just to be safe...",,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,// reference type,,,unknown,no,0
,// --- Inner classes (moved here from sql-gen.g) ---,,,unknown,no,0
,// no existing row - do an insert,,,unknown,no,0
,//else do nothing (don't even reassociate object!),,,unknown,no,0
,//will result in a SQL UPDATE:,,,unknown,no,0
,//stops flush being called multiple times if this method is recursively called,,,unknown,no,0
,/// HHH-2378,,,unknown,no,0
,//what is the version on the database?,,,unknown,no,0
,// do the put outside the scope of the JTA txn,,,unknown,no,0
,// get the id from the object,,,unknown,no,0
,//ignore!,,,unknown,no,0
,// evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// get meta's from <subclass>,,,unknown,no,0
,//60 seconds,,,unknown,no,0
,// ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);,,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,"// some filters affecting the collection are enabled on the session, so do not do the put into the cache.",,,unknown,no,0
,// A session is considered to contain an entity only if the entity has // an entry in the session's persistence context and the entry reports // that the entity has not been removed,,,unknown,no,0
,// we are now at a new tree level,,,unknown,no,0
,// ... and the token could be an identifer and the error is // a mismatched token error ...,,,unknown,no,0
,//some statistics,,,unknown,no,0
,// Use the token as an identifier.,,,unknown,no,0
,// double,,,unknown,no,0
,"//now done in EntityIdentityInsertAction //persister.setIdentifier( entity, id, source.getEntityMode() );",,,unknown,no,0
,// double,,,unknown,no,0
,// Delegate to the QueryLoader...,,,unknown,no,0
,// -- Package local methods for the QueryLoader delegate --,,,unknown,no,0
,// Remember the parameters for the compilation.,,,unknown,no,0
,// Delegate to the QueryLoader...,,,unknown,no,0
,// NOTE : ( max - 1 ) because first is zero-based while max is not...,,,unknown,no,0
,// intializes result by side-effect,,,unknown,no,0
,// Entity was found in second-level cache...,,,unknown,no,0
,// this object was already loaded,,,unknown,no,0
,// return new uninitialized proxy,,,unknown,no,0
,"//We do not look for an existing join on the same path, because //it makes sense to join twice on the same collection role",,,unknown,no,0
,"// If the propertyType is null and there isn't a parent, just // stop now... there was a problem resolving the node anyway.",,,unknown,no,0
,"// Resolve the LHS fully, generate implicit joins.  Pass in the property name so that the resolver can // discover foreign key (id) properties.",,,unknown,no,0
,"// Default implementation: // If this node has a data type, and that data type is not an association, then this is scalar.",,,unknown,no,0
,"// If a where clause was specified in the update/delete query, use it to limit the // returned ids here...",,,unknown,no,0
,// the Interceptor handled the dirty checking,,,unknown,no,0
,// If the token can tell us if it could be an identifier...,,,unknown,no,0
,"// Don't need to lock the cache here, since if someone // else inserted the same pk first, the insert would fail",,,unknown,no,0
,// (NOT (NOT_LIKE a b) ) => (LIKE a b),,,unknown,no,0
,"// if the version of a newly instantiated object is not the same // as the version seed value, use that as the unsaved-value",,,unknown,no,0
,"// The unique property value represented here may or may not be // serializable, so we do an explicit check here in order to generate // a better error message",,,unknown,no,0
,// (NOT (IS_NOT_NULL a b) ) => (IS_NULL a b),,,unknown,no,0
,// detached collection wrappers that get found + reattached // during flush shouldn't be ignored,,,unknown,no,0
,// The CollectionEntry.isReached() stuff is just to detect any silly users   // who set up circular or shared references between/to collections.,,,unknown,no,0
,// (NOT (LIKE a b) ) => (NOT_LIKE a b),,,unknown,no,0
,// This 'dot' expression now refers to the resulting from element.,,,unknown,no,0
,// check nullability but do not perform command execute // we'll use scheduled updates for that.,,,unknown,no,0
,// if it was dirtied by a collection only,,,unknown,no,0
,// compare to cached state (ignoring collections unless versioned),,,unknown,no,0
,// (NOT (EQ a b) ) => (NE a b),,,unknown,no,0
,"// give the Interceptor a chance to process property values, if the properties // were modified by the Interceptor, we need to set them back to the object",,,unknown,no,0
,// substitutes into values by side-effect,,,unknown,no,0
,// schedule the update // note that we intentionally do _not_ pass in currentPersistentState!,,,unknown,no,0
,"//slice, to get the columns for this component //property",,,unknown,no,0
,// watch out for a case where old is still referenced // somewhere in the object graph! (which is a user error),,,unknown,no,0
,"// if the natural-id is marked as non-mutable, it is not retrieved during a // normal database-snapshot operation...",,,unknown,no,0
,// collection deletions are a special case since update() can add // deletions of collections not loaded by the session.,,,unknown,no,0
,// this will throw an error if there's something wrong.,,,unknown,no,0
,// ie. we never have to null out a reference to // an uninitialized proxy,,,unknown,no,0
,//give the Interceptor a chance to modify property values,,,unknown,no,0
,// [jsd] The fix for HHH-558...,,,unknown,no,0
,//use the current version,,,unknown,no,0
,// igndore it...,,,unknown,no,0
,"// ... and the expected token type was an identifier, then:",,,unknown,no,0
,"//the entity is not associated with the session, so //try interceptor and unsaved-value",,,unknown,no,0
,// (NOT (LT a b) ) => (GE a b),,,unknown,no,0
,// (NOT (GE a b) ) => (LT a b),,,unknown,no,0
,// (NOT (LE a b) ) => (GT a b),,,unknown,no,0
,// Sub-insertions should occur before containing insertion so // Try to do the callback now,,,unknown,no,0
,"//we must clone embedded composite identifiers, or  //we will get back the same instance that we pass in",,,unknown,no,0
,// (NOT (NE a b) ) => (EQ a b),,,unknown,no,0
,"// now, any collections that are initialized // inside this block do not get updated - they // are ignored until the next flush",,,unknown,no,0
,"// upgrade the lock if necessary: //lock(result, lockMode);",,,unknown,no,0
,"// skip this check for composite-ids relating to dom4j entity-mode; // alternatively, we could add a check to make sure the incoming id value is // an instance of Element...",,,unknown,no,0
,// wrap up any new collections directly referenced by the object // or its components,,,unknown,no,0
,"// this implementation is supposed to tolerate incorrect unsaved-value // mappings, for the purpose of backward-compatibility",,,unknown,no,0
,"// this implementation is supposed to tolerate incorrect unsaved-value // mappings, for the purpose of backward-compatibility",,,unknown,no,0
,// dirty check against the usual snapshot of the entity,,,unknown,no,0
,"// Entity load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // 	* currently, not yet used...",,,unknown,no,0
,"// ignore this row, the collection is in process of // being loaded somewhere further ""up"" the stack",,,unknown,no,0
,// object loaded by update(),,,unknown,no,0
,//safe from concurrent modification because of how entryList() is implemented on IdentityMap,,,unknown,no,0
,// Transform the tree.,,,unknown,no,0
,// Parse the query string into an HQL AST.,,,unknown,no,0
,// The uber-rule here is that we need to include  subclass joins if // the FromElement is in any way dereferenced by a property from // the subclass table; otherwise we end up with column references // qualified by a non-existent table reference in the resulting SQL...,,,unknown,no,0
,//sqlResultTypeList.add( type ); // Generate the select expression.,,,unknown,no,0
,//explicit = true;	// This is an explict Select. //ArrayList sqlResultTypeList = new ArrayList();,,,unknown,no,0
,"// Reset the node type, because the rest of the system is expecting FROM_FRAGMENT, all we wanted was // for the factory to create the right sub-class.  This might get reset again later on anyway to make the // SQL generation simpler.",,,unknown,no,0
,//		origin.addDestination(destination); // Add the query spaces.,,,unknown,no,0
,"// This uses a PathExpressionParser but notice that compound paths are not valid, // only bare names and simple paths:",,,unknown,no,0
,"// If the first identifier in the path referrs to the class alias (not the class name), then this // is a correlated subselect.  If it's a correlated sub-select, use the existing table alias.  Otherwise // generate a new one.",,,unknown,no,0
,"// Otherwise, the destination node was implied by the FROM clause and the FROM clause processor // will automatically add it in the right place.",,,unknown,no,0
,// Not a collection? // Return the entity property mapping.,,,unknown,no,0
,// check that entity id = requestedId,,,unknown,no,0
,"// cascade first, so that all unsaved objects get their // copy created before we actually copy",,,unknown,no,0
,// continue...; we'll find out if it ends up not getting saved later,,,unknown,no,0
,//before cascade!,,,unknown,no,0
,"/*				 * Property prop = new Property(); prop.setName(""id"");				 * prop.setPropertyAccessorName(""embedded""); prop.setValue(id);				 * entity.setIdentifierProperty(prop);				 */",,,unknown,no,0
,// 60 second lock timeout,,,unknown,no,0
,// Set the unresolved path in this node and the parent. // Set the text for the parent.,,,unknown,no,0
,//DELETED,,,unknown,no,0
,// Check the persistence context for an entry relating to this // entity to be merged...,,,unknown,no,0
,//EARLY EXIT!,,,unknown,no,0
,// Initialize SQL nodes here.,,,unknown,no,0
,"// If the expression list has exactly one expression, and the type of the expression is a collection // then this might be a collection function, such as index(c) or size(c).",,,unknown,no,0
,//before cascade!,,,unknown,no,0
,"// we do not actually propogate ANTLRExceptions as a cause, so // log it here for diagnostic purposes",,,unknown,no,0
,"// cascade first, so that all unsaved objects get their  // copy created before we actually copy",,,unknown,no,0
,"// local cache, so we use synchronization",,,unknown,no,0
,//maintain correct duplication if loaded in a cartesian product,,,unknown,no,0
,"// If the workspace node has null as well, OK; if not we've // been modified in a non-comparable manner, which we have to // treat as us being newer",,,unknown,no,0
,"// See if we had a 2nd invalidation from the same initial // preinvalidation timestamp. If so, only increment // if the new current value is an increase",,,unknown,no,0
,// We don't want to waste effort setting an option if JBC is // already in LOCAL mode. If JBC is REPL_(A)SYNC then check // if they passed an config option to disable query replication,,,unknown,no,0
,// This method should be implemented assuming it's valid to  // do start/stop/start -- leave state appropriate for another start,,,unknown,no,0
,// PERSISTER,,,unknown,no,0
,//true if this is a query and we are loading multiple instances of the same collection role //otherwise this is a CollectionInitializer and we are loading up a single collection or batch,,,unknown,no,0
,"// We now have the value of the property-ref we reference.  However, // we need to dig a little deeper, as that property might also be // an entity type, in which case we need to resolve its identitifier",,,unknown,no,0
,"// If we have <tt>not-found=""ignore""</tt> association mapped to a // formula, we always need to dirty check it, so we can update the // second-level cache",,,unknown,no,0
,"//this should be a call to resolve(), not resolveIdentifier(),  //'cos it might be a property-ref, and we did not cache the //referenced value",,,unknown,no,0
,"//do not use proxiesByKey, since not all //proxies that point to this session's //instances are in that collection!",,,unknown,no,0
,// should not be able to reach last without maxPosition being set // unless there are no results,,,unknown,no,0
,"//for arrays, replaceElements() may return a different reference, since //the array length might not match",,,unknown,no,0
,// Retrieve the value of the designated column in the current row of this // ResultSet object as a java.io.Reader object,,,unknown,no,0
,"// as soon as we encounter our first letter, return the substring // from that position",,,unknown,no,0
,// no need to even collect this information if the persister is considered multi-table,,,unknown,no,0
,// The following variables are stacks that keep information about each subexpression // in the list of nested subexpressions we are currently processing.,,,unknown,no,0
,"//copyValues works by reflection, so explicitly mark the entity instance dirty",,,unknown,no,0
,// find any entities that are still transient after retry,,,unknown,no,0
,// semantic action processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// if template is null we just write the function out as it appears in the hql statement,,,unknown,no,0
,//NOTE: EARLY EXIT!,,,unknown,no,0
,"// Ignore the token class name parameter, and use a specific token class.",,,unknown,no,0
,// all clear,,,unknown,no,0
,//overriden to avoid System.exit,,,unknown,no,0
,// remember that ordinal parameters numbers are 1-based!!!,,,unknown,no,0
,/* package-private */,,,unknown,no,0
,/* package-private */,,,unknown,no,0
,"// If the query is already compiled, skip the compilation.",,,unknown,no,0
,//overriden to avoid System.exit,,,unknown,no,0
,// right represents a joins originating from left...,,,unknown,no,0
,"/*public final Currency getCurrency(int col) throws HibernateException {		return (Currency) get(col);	}*/",,,unknown,no,0
,//get a snapshot,,,unknown,no,0
,// key is an entity involved with the operation performed by the listener; // value is a flag indicating if the listener explicitly operates on the entity,,,unknown,no,0
,// PHASE 1 : Parse the HQL into an AST.,,,unknown,no,0
,"//the database has changed now, so the subselect results need to be invalidated",,,unknown,no,0
,// we need to lock the collection caches before // executing entity inserts/updates in order to // account for bidi associations,,,unknown,no,0
,// Schedule updates to collections:,,,unknown,no,0
,"// Update the status of the object and if necessary, schedule an update",,,unknown,no,0
,//only needed during compilation phase...,,,unknown,no,0
,// So this needs to be safe from concurrent modification problems. // It is safe because of how IdentityMap implements entrySet(),,,unknown,no,0
,//this is a query and we are loading multiple instances of the same collection role,,,unknown,no,0
,// EARLY EXIT!!!,,,unknown,no,0
,"// before any callbacks, etc, so subdeletions see that this deletion happened first",,,unknown,no,0
,// this is a transient object with existing persistent state not loaded by the session,,,unknown,no,0
,//ie. the entity came in from update(),,,unknown,no,0
,// note: performExecutions() clears all collectionXxxxtion  // collections (the collection actions) in the session,,,unknown,no,0
,//EARLY EXIT!,,,unknown,no,0
,"//log.debug( ""calling onLoad()"" );",,,unknown,no,0
,"// if the collection belonged to a different entity, // clean up the existing state of the collection",,,unknown,no,0
,"//a ""detached"" collection!",,,unknown,no,0
,"//cachedState,",,,unknown,no,0
,"// check two ""adjecent"" nodes at the top of the from-clause tree",,,unknown,no,0
,// assume this is a newly instantiated transient object // which should be saved rather than updated,,,unknown,no,0
,// Ensures that containing deletions happen before sub-deletions,,,unknown,no,0
,//TRANSIENT or DELETED,,,unknown,no,0
,//return the id in the event object,,,unknown,no,0
,//initialize properties of the event:,,,unknown,no,0
,"// an uninitialized proxy, noop, don't even need to // return an id, since it is never a save()",,,unknown,no,0
,"//assign the requested id to the proxy, *before* //reassociating the proxy",,,unknown,no,0
,"// if it is an initialized proxy, let cascade // handle it later on",,,unknown,no,0
,// cascade-delete to many-to-one AFTER the parent was deleted,,,unknown,no,0
,// cascade-delete to collections BEFORE the collection owner is deleted,,,unknown,no,0
,// grab its current state,,,unknown,no,0
,//grab its state saved at deletion,,,unknown,no,0
,// this is a situation where the entity id is assigned by a post-insert generator // and was saved outside the transaction forcing it to be delayed,,,unknown,no,0
,"// Next, try to locate this resource through the system classloader",,,unknown,no,0
,"// First, try to locate this resource through the current // context classloader.",,,unknown,no,0
,// make sure spinning forward did not put us past the end of the buffer...,,,unknown,no,0
,"// we have a placeholder, spin forward till we find the end",,,unknown,no,0
,// and this is not a forced initialization during flush,,,unknown,no,0
,// Print page,,,unknown,no,0
,// there were no queued additions // and the role has a cache,,,unknown,no,0
,"// if we reach the end of the string w/o finding the // matching end, that is an exception",,,unknown,no,0
,// peek ahead,,,unknown,no,0
,"// set last used iterator here, in case the user calls remove // before calling hasNext() or next() (although they shouldn't)",,,unknown,no,0
,//doable if needed,,,unknown,no,0
,// call this before any Iterator method to make sure that the current Iterator // is not exhausted,,,unknown,no,0
,//it was a boolean expression,,,unknown,no,0
,// the last used iterator,,,unknown,no,0
,// the current iterator,,,unknown,no,0
,// index of current iterator in the wrapped iterators array,,,unknown,no,0
,// wrapped iterators,,,unknown,no,0
,// entityNames may now include slashes for the representations //classname may be an inner class,,,unknown,no,0
,// first time we find match!,,,unknown,no,0
,// +1 to include the following '.',,,unknown,no,0
,"// Next, try to locate this resource through this class's classloader",,,unknown,no,0
,// Anywhere else we should look?,,,unknown,no,0
,// Start the session to be used for this request,,,unknown,no,0
,//Arrays.asList doesn't do primitive arrays,,,unknown,no,0
,// Write HTML header,,,unknown,no,0
,"// Make sure you log the exception, as it might be swallowed",,,unknown,no,0
,"// Defensive, convenience methods",,,unknown,no,0
,"//cfg.setProperty(""hibernate.show_sql"", ""true"");",,,unknown,no,0
,//readResolveObject,,,unknown,no,0
,//context.unbind(boundName);,,,unknown,no,0
,// Its the listener instance (or better be),,,unknown,no,0
,//entirely optional!!,,,unknown,no,0
,// Make sure we don't override previous set values,,,unknown,no,0
,"// first, lets determine whether to apply cglib or javassist based instrumentation...",,,unknown,no,0
,// look for the instance by uuid,,,unknown,no,0
,// default to element set if no elements() specified,,,unknown,no,0
,"//allow 9,8,7,6,5,4,3,2,1",,,unknown,no,0
,// Its the listener class name,,,unknown,no,0
,// the name of a class,,,unknown,no,0
,// right represents a joins originating from left; or // both right and left reprersent joins originating from the same FromElement,,,unknown,no,0
,"//pass the entity-name, if not a collection-id",,,unknown,no,0
,//faster?,,,unknown,no,0
,// aload_0,,,unknown,no,0
,// includes last '.',,,unknown,no,0
,// returnign null!,,,unknown,no,0
,// returnign null!,,,unknown,no,0
,/*&& !('_'==character)*/,,,unknown,no,0
,//cannot batch fetch by unique key (property-ref associations),,,unknown,no,0
,// Some JDBC drivers erroneously return an empty array here for a null DB value :/,,,unknown,no,0
,"// create a new collection wrapper, to be initialized later",,,unknown,no,0
,// initialize this collection,,,unknown,no,0
,"// check if it is already completely loaded, but unowned",,,unknown,no,0
,// check if collection is currently being loaded,,,unknown,no,0
,// get the elements back into the target making sure to handle dirty flag,,,unknown,no,0
,// DISCRIMINATOR,,,unknown,no,0
,//we ran out of ids to try,,,unknown,no,0
,//the first id found after the given id,,,unknown,no,0
,// by default just use an unanticipated capacity since we don't // know how to extract the capacity to use from original here...,,,unknown,no,0
,//we ran out of keys to try,,,unknown,no,0
,"// for a null target, or a target which is the same as the original, we // need to put the merged elements in a new collection",,,unknown,no,0
,"//end of array, start filling again from start",,,unknown,no,0
,// copy elements into newly empty target collection,,,unknown,no,0
,//ignore subselect keywords,,,unknown,no,0
,//checkForEnd = false;,,,unknown,no,0
,"// the key is the owning entity itself, so get the ID from the key",,,unknown,no,0
,//NOTE: we avoid joining to the next table if the named property is just the foreign key value,,,unknown,no,0
,//delete all the deleted entries,,,unknown,no,0
,//the owner of the association is not the owner of the id,,,unknown,no,0
,// ----------------------------------------------------------- Constructors,,,unknown,no,0
,//its an interface so we can't really tell anything...,,,unknown,no,0
,/* static methods only - hide constructor */,,,unknown,no,0
,// stream closed in the finally,,,unknown,no,0
,// warning: can cause a recursive calls! (proxy initialization),,,unknown,no,0
,// Serialize //-----------------------------------------------------------------------,,,unknown,no,0
,// Clone //-----------------------------------------------------------------------,,,unknown,no,0
,"// we want to be able to just use the defaults, // if JNDI environment properties are not supplied // so don't put null in anywhere",,,unknown,no,0
,//NOTE: early return,,,unknown,no,0
,// use default behavior,,,unknown,no,0
,//its an interface so we can't really tell anything...,,,unknown,no,0
,// ----------------------------------------------------- Instance Variables,,,unknown,no,0
,"// try to ""pretty print"" it",,,unknown,no,0
,// release the jdk internal caches everytime to ensure this // plays nicely with destroyable class-loaders,,,unknown,no,0
,// release the jdk internal caches everytime to ensure this // plays nicely with destroyable class-loaders,,,unknown,no,0
,// stream closed in the finally,,,unknown,no,0
,"//Sybase fail if we don't do that, sigh...",,,unknown,no,0
,// Simple tests that require no synchronization,,,unknown,no,0
,// Compare the two maps for equality,,,unknown,no,0
,// --------------------------------------------------------- Public Methods,,,unknown,no,0
,// Handle actions,,,unknown,no,0
,// cleanup code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//Named Queries:,,,unknown,no,0
,// The default SQLExceptionConverter for all dialects is based on SQLState // since SQLErrorCode is extremely vendor-specific.  Specific Dialects // may override to return whatever is most appropriate for that vendor.,,,unknown,no,0
,"// collectionPersister should not be null, but we don't want to throw // an exception if it is null",,,unknown,no,0
,// Set it!,,,unknown,no,0
,//saveOrUpdateCopy() is deprecated!,,,unknown,no,0
,// collections detect changes made via their public interface and mark // themselves as dirty as a performance optimization,,,unknown,no,0
,"// note that it might be better to iterate the snapshot but this is safe, // assuming the user implements equals() properly, as required by the Set // contract!",,,unknown,no,0
,//element //index -> id,,,unknown,no,0
,//	void setComponentTuplizerFactory(ComponentTuplizerFactory componentTuplizerFactory) { //		this.componentTuplizerFactory = componentTuplizerFactory; //	},,,unknown,no,0
,"// a ""detached"" collection that belonged to a different entity",,,unknown,no,0
,// finally handle the exception,,,unknown,no,0
,// state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// so we ""clock over"" on the first invocation",,,unknown,no,0
,// DYNAMIC INSERT,,,unknown,no,0
,"// create the node initially with the param name so that it shows // appropriately in the ""original text"" attribute",,,unknown,no,0
,"//NOTE SPECIAL CASE: // default to join and non-lazy for the ""second join"" // of the many-to-many",,,unknown,no,0
,// parameters on the property mapping should // override parameters in the typedef,,,unknown,no,0
,//ignore!,,,unknown,no,0
,// get meta's from // <joined-subclass>,,,unknown,no,0
,//do the failfast put outside the scope of the JTA txn,,,unknown,no,0
,// ignore,,,unknown,no,0
,"// Case 1: Multi token keywords GROUP BY and ORDER BY // The next token ( LT(2) ) should be 'by'... otherwise, this is just an ident.",,,unknown,no,0
,//only necessary for postgre < 7.4 //http://anoncvs.postgresql.org/cvsweb.cgi/pgsql/doc/src/sgml/ref/create_sequence.sgml,,,unknown,no,0
,"// make the session available to the session factory's ""current context""",,,unknown,no,0
,"// otherwise a null or brand new collection // this will also (inefficiently) handle arrays, which // have no snapshot, so we can't do any better //processArrayOrNewCollection(collection, type);",,,unknown,no,0
,// now update the object .. has to be outside the main if block above (because of collections),,,unknown,no,0
,"// the database now holds a lock + the object is flushed from the cache, // so release the soft lock",,,unknown,no,0
,"// if // if // Otherwise, handle the error normally.",,,unknown,no,0
,//Force a substitution!,,,unknown,no,0
,"// The path AST should be a DotNode, and it should have been evaluated already.",,,unknown,no,0
,// (EQ a NULL) => (IS_NULL a),,,unknown,no,0
,// Add NOT if it's negated.,,,unknown,no,0
,//do nothing,,,unknown,no,0
,// Create nodes that track line and column number.,,,unknown,no,0
,// (EQ NULL b) => (IS_NULL b),,,unknown,no,0
,// Whether this dialect has an Identity clause added to the data type or a completely seperate identity // data type,,,unknown,no,0
,"// TRIM(end_keyword string-expression-1 FROM string-expression-2) // use Hibernate implementation ""From"" is one of the parameters they pass in position ?3 //registerFunction( ""trim"", new SQLFunctionTemplate(Hibernate.STRING, ""trim(?1 ?2 from ?3)"") );",,,unknown,no,0
,//do nothing,,,unknown,no,0
,// Case 2: The current token is after FROM and before '.'.,,,unknown,no,0
,// See if the second lookahed token can be an identifier.,,,unknown,no,0
,"// Note: For object <-> SQL datatype mappings see: //	 Configuration Manager | Advanced | SQL | System DDL Datatype Mappings // //	TBD	registerColumnType(Types.BINARY,        ""binary($1)""); // changed 08-11-2005, jsl",,,unknown,no,0
,//		 You may still have other ResultSets or update counts left to process here  //		 but you can't do it now or the ResultSet you just got will be closed ,,,unknown,no,0
,// add the comment // nest the main query in an outer select // add the rownnumber bit into the outer query select list,,,unknown,no,0
,"// a ""detached"" collection that originally belonged to the same entity",,,unknown,no,0
,// perform the actual work,,,unknown,no,0
,//keep the behavior consistent even for boundary usages,,,unknown,no,0
,//keep the behavior consistent even for boundary usages,,,unknown,no,0
,// transfer an explicitly defined entity name // handle the lazy attribute,,,unknown,no,0
,// assumes that types are all of span 1,,,unknown,no,0
,/*package*/,,,unknown,no,0
,"// (AS is always optional, for consistency with SQL/OQL)",,,unknown,no,0
,// the cache of the actual plans...,,,unknown,no,0
,/*package*/,,,unknown,no,0
,// Collection load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// loading collection xrefs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// Configured outside of Hibernate (i.e. Servlet container, or Java Bean Container // already has Proxool pools running, and this provider is to just borrow one of these",,,unknown,no,0
,"// Not null if the Isolation level has been specified in the configuration file. // Otherwise, it is left to the Driver's default value.",,,unknown,no,0
,"// JBC put a version in the node when it created as part of // some internal operation. We are always newer, but if // the JBC version is > 1 something odd has happened",,,unknown,no,0
,"// Don't hold the JBC node lock throughout the tx, as that // prevents reads and other updates",,,unknown,no,0
,// The getEmailAddresses() might trigger a lazy load of the collection,,,unknown,no,0
,// Reattachment of aPerson,,,unknown,no,0
,// Begin second unit of work,,,unknown,no,0
,"// or bidirectional safety method, setting both sides: aPerson.addToEvent(anEvent);",,,unknown,no,0
,// End of first unit of work,,,unknown,no,0
,"/*        Event anEvent = (Event) session                .createCriteria(Event.class).setFetchMode(""participants"", FetchMode.JOIN)                .add( Expression.eq(""id"", eventId) )                .uniqueResult(); // Eager fetch the colleciton so we can use it detached        */",,,unknown,no,0
,// Eager fetch the collection so we can use it detached,,,unknown,no,0
,"// remove session from ""current context""",,,unknown,no,0
,"// process the ""new"" HQL style where aliases are assigned // _after_ the class name or path expression ie. using // the AS construction",,,unknown,no,0
,// is a primitive type // invokespecial,,,unknown,no,0
,// Start performing the updates,,,unknown,no,0
,// jdbc params are 1-based,,,unknown,no,0
,//cannot be instantiated,,,unknown,no,0
,//60 seconds,,,unknown,no,0
,// at the very least cleanup the data :),,,unknown,no,0
,"// make sure this ""name"" is an integral",,,unknown,no,0
,// a peek ahead showed this as an JPA-positional parameter,,,unknown,no,0
,"// strip the "" where """,,,unknown,no,0
,// could be either an ordinal or JPA-positional parameter,,,unknown,no,0
,// named parameter,,,unknown,no,0
,"//handle <=, >=, !=, is not, not between, not in",,,unknown,no,0
,// array of primitive type // do nothing,,,unknown,no,0
,"// don't care about other param types here, just those explicitly user-defined...",,,unknown,no,0
,// don't care...,,,unknown,no,0
,//important: reuse the same event instances for performance!,,,unknown,no,0
,"// handle a path expression or class name that // appears at the start, in the ""new"" HQL // style or an alias that appears at the start // in the ""old"" HQL style",,,unknown,no,0
,// Recognition code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// on the inverse, it makes sense that if a ThreadLocalSessionContext- // bound session then gets deserialized to go ahead and re-bind it to // the ThreadLocalSessionContext session map.",,,unknown,no,0
,// don't care...,,,unknown,no,0
,// jdbc params are 1-based,,,unknown,no,0
,"/*DataSource unpooled = DataSources.unpooledDataSource(				jdbcUrl, props.getProperty(Environment.USER), props.getProperty(Environment.PASS)			);*/",,,unknown,no,0
,"// we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flush",,,unknown,no,0
,// eat it and try next,,,unknown,no,0
,//private Type[] sqlResultTypes;,,,unknown,no,0
,//scan for next non-whitespace token,,,unknown,no,0
,// the standard SQL function name is current_timestamp...,,,unknown,no,0
,// Error message constants.,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// use setParameter for null values,,,unknown,no,0
,"// Interceptor returned null, so do the dirtycheck ourself, if possible",,,unknown,no,0
,"// For implied many-to-many, just add the end join.",,,unknown,no,0
,/*implied*/,,,unknown,no,0
,"//  origin, path, implied, columns, classAlias,",,,unknown,no,0
,// use setParameter for null values,,,unknown,no,0
,// default is POJO,,,unknown,no,0
,// Get the class name of the associated entity.,,,unknown,no,0
,//public Currency getCurrency(int col) throws HibernateException;,,,unknown,no,0
,// Tag this node as a JOIN. // Don't include subclasses in the join. // This is a clollection join.,,,unknown,no,0
,//always overwrite nonversioned data,,,unknown,no,0
,// not really a many-to-one association *necessarily*,,,unknown,no,0
,"// The associated entity is implied, but it must be included in the FROM. // The collection alias is the role.",,,unknown,no,0
,// not really a many-to-one association *necessarily*,,,unknown,no,0
,// This causes the factory to instantiate the desired class.,,,unknown,no,0
,//private CacheEntry cacheEntry;,,,unknown,no,0
,"// If the join is implied, then don't include sub-classes on the element.",,,unknown,no,0
,//Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!,,,unknown,no,0
,"/*sqlResultTypeList,*/",,,unknown,no,0
,//then by fk,,,unknown,no,0
,"//update last non-whitespace token, if necessary",,,unknown,no,0
,// function support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//sort first by role name,,,unknown,no,0
,// need to look it up from the persistence-context,,,unknown,no,0
,// just especially for the trivial collection filter,,,unknown,no,0
,/*|| oj.getJoinable().consumesCollectionAlias() */,,,unknown,no,0
,//EARLY EXIT!,,,unknown,no,0
,// Get ready to start adding nodes.,,,unknown,no,0
,// add the fetched entities,,,unknown,no,0
,"// this entity defines proeprty generation, so process those generated // values...",,,unknown,no,0
,"// have the entity entry perform post-update processing, passing it the // update state and the new version (if one).",,,unknown,no,0
,// Always add the type to the return type list.,,,unknown,no,0
,//sqlResultTypeList.add( type );,,,unknown,no,0
,//sqlResultTypeList.addAll( constructorArgumentTypeList );,,,unknown,no,0
,"/*public Type[] getSqlResultTypes() {		return sqlResultTypes;	}*/",,,unknown,no,0
,"// Frontbase has no known variation of a ""SELECT ... FOR UPDATE"" syntax...",,,unknown,no,0
,"//		TypeFactory.deepCopy( currentState, propTypes, persister.getPropertyUpdateability(), deletedState, session );",,,unknown,no,0
,// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Create the FROM element for the target (the elements of the collection).,,,unknown,no,0
,//test out the optimizer:,,,unknown,no,0
,"// If the from element isn't in the same clause, create a new from element.",,,unknown,no,0
,// Add to the query spaces.,,,unknown,no,0
,// toggle autoCommit to false if set,,,unknown,no,0
,// Look up class name using the first identifier in the path.,,,unknown,no,0
,"// do *not* over-write the column text, as that has already been // ""rendered"" during resolve",,,unknown,no,0
,// naked property-refs cannot be used with an aliased from element,,,unknown,no,0
,// set the Transaction Isolation if defined,,,unknown,no,0
,"// get a connection from the pool (thru DriverManager, cfr. Proxool doc)",,,unknown,no,0
,// assume we do *not* refer to a property on the given persister,,,unknown,no,0
,"// TRUE if the pool is borrowed from the outside, FALSE if we used to create it",,,unknown,no,0
,// assume we do *not* refer to a property on the given persister,,,unknown,no,0
,// these pieces are needed for usage in select clause,,,unknown,no,0
,"// check to see if our ""propPath"" actually // represents a property on the persister",,,unknown,no,0
,"// This is not actually a constant, but a reference to FROM element.",,,unknown,no,0
,"// just ignore it for now, it'll get resolved later...",,,unknown,no,0
,// assume this ident's text does *not* refer to a property on the given persister,,,unknown,no,0
,// EARLY EXIT!!!  return so the resolve call explicitly coming from DotNode can // resolve this...,,,unknown,no,0
,// we represent a naked (simple) prop-ref,,,unknown,no,0
,// we are the RHS of the DOT representing a naked comp-prop-ref,,,unknown,no,0
,// We represent a from-clause alias,,,unknown,no,0
,// return the connection,,,unknown,no,0
,// Correlated subqueries create 'special' implied from nodes // because correlated subselects can't use an ANSI-style join,,,unknown,no,0
,"// the ""root from-element"" in correlated subqueries do need this piece",,,unknown,no,0
,// super-duper-classic-parser-regression-testing-mojo-magic...,,,unknown,no,0
,"// NOTE: Because we're using ASTUtil.createParent(), the tree must be created from the bottom up. // IS EMPTY x => (EXISTS (QUERY (SELECT_FROM (FROM x) ) ) )",,,unknown,no,0
,// If the provider was leeching off an existing pool don't close it,,,unknown,no,0
,// Remember Isolation level,,,unknown,no,0
,// Configured using the Properties File Configurator,,,unknown,no,0
,// Append the stem to the proxool pool alias,,,unknown,no,0
,// Append the stem to the proxool pool alias,,,unknown,no,0
,// Configured using the JAXP Configurator,,,unknown,no,0
,// Append the stem to the proxool pool alias,,,unknown,no,0
,// semantic action handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// Treat explict from elements in sub-queries properly.,,,unknown,no,0
,// Don't include sub-classes for implied collection joins or subquery joins.,,,unknown,no,0
,// Validate that an alias name was provided to determine which pool to use,,,unknown,no,0
,// We only build caches if *none* were passed in.  Passing in // caches counts as a clear statement of exactly what is wanted,,,unknown,no,0
,// Validate that an alias name was provided to determine which pool to use,,,unknown,no,0
,// A collection of scalar elements...,,,unknown,no,0
,// Default the Proxool alias setting,,,unknown,no,0
,// A collection of components...,,,unknown,no,0
,// A collection of entities...,,,unknown,no,0
,// Get the configurator files (if available),,,unknown,no,0
,// nothing to do		,,,unknown,no,0
,"/*ArrayList sqlResultTypeList,*/",,,unknown,no,0
,// nothing to do,,,unknown,no,0
,// aload_3 // load the raw bean,,,unknown,no,0
,"// If there is a second child (RHS), recurse into that child.",,,unknown,no,0
,// new,,,unknown,no,0
,"// If the node has a first child, recurse into the first child.",,,unknown,no,0
,// Append the text of the current node.,,,unknown,no,0
,"// Use the DOT node to emit the first column name. // Create the column names, folled by the column aliases.",,,unknown,no,0
,// aload_0,,,unknown,no,0
,// determine the type of the first argument...,,,unknown,no,0
,// locate the registered function by the given name,,,unknown,no,0
,"// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)",,,unknown,no,0
,"// If that didn't work, try using the 'import' name.",,,unknown,no,0
,// unable to locate it using this name,,,unknown,no,0
,// iconst_i // continue to aastore // growing stack is 1,,,unknown,no,0
,"// First, try to get the persister using the given name directly.",,,unknown,no,0
,"// Put the THETA_JOINS node before the HQL condition, after the filters.",,,unknown,no,0
,// aload_2 // args,,,unknown,no,0
,// Create a new THETA_JOINS node as a parent of all filters,,,unknown,no,0
,// add the current fragment to the FILTERS node,,,unknown,no,0
,// astore_3 // store bean,,,unknown,no,0
,// Put the FILTERS node before the HQL condition and theta joins,,,unknown,no,0
,// dup,,,unknown,no,0
,// invokeinterface,,,unknown,no,0
,// this method is called when a new non-null collection is persisted // or when an existing (non-null) collection is moved to a new owner,,,unknown,no,0
,// invokevirtual,,,unknown,no,0
,// iconst_i,,,unknown,no,0
,"// Otherwise, try to use the no-arg constructor",,,unknown,no,0
,// aload_2 // load the args,,,unknown,no,0
,// oracle sql-state code for deadlock,,,unknown,no,0
,// The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.,,,unknown,no,0
,"// SELECT p FROM p IN CLASS eg.Person ORDER BY p.Name, p.Address, p",,,unknown,no,0
,// aload 4 // load the raw bean,,,unknown,no,0
,"// This uses a PathExpressionParser but notice that compound paths are not valid, // only bare names and simple paths:",,,unknown,no,0
,"// The FROM fragment will probably begin with ', '.  Remove this if it is present.",,,unknown,no,0
,"// iinc 3, 1",,,unknown,no,0
,/*&& StringHelper.isNotEmpty( frag )*/,,,unknown,no,0
,"// If there is a FROM fragment and the FROM element is an explicit, then add the from part.",,,unknown,no,0
,// start region to handling exception (BulkAccessorException),,,unknown,no,0
,"// Iterate through the alias,JoinSequence pairs and generate SQL token nodes.",,,unknown,no,0
,/* current stack len = 0 */,,,unknown,no,0
,// aload_1 // load the bean,,,unknown,no,0
,// istore_3 // store i,,,unknown,no,0
,// aastore // args,,,unknown,no,0
,// invokevirtual,,,unknown,no,0
,// checkcast // cast bean,,,unknown,no,0
,"// Filter conditions need to be inserted before the HQL where condition and the // theta join node.  This is because org.hibernate.loader.Loader binds the filter parameters first, // then it binds all the HQL query parameters, see org.hibernate.loader.Loader.processFilterParameters().",,,unknown,no,0
,// aload_1 // load bean,,,unknown,no,0
,// Find or create the WHERE clause,,,unknown,no,0
,//then by id,,,unknown,no,0
,// If this is 'elements' then create a new FROM element.,,,unknown,no,0
,//sort first by entity name,,,unknown,no,0
,// areturn // return the value of the field,,,unknown,no,0
,// Method expressions in a SELECT should always be considered scalar.,,,unknown,no,0
,"// This handles HHH-354, where there is a strange property name in a where clause. // If the lookahead contains a DOT then something that isn't an IDENT...",,,unknown,no,0
,// aload_0,,,unknown,no,0
,// Get the function name node.,,,unknown,no,0
,// Generate the property select tokens.,,,unknown,no,0
,"// Skip 'DISTINCT' and 'ALL', so we return the first expression node.",,,unknown,no,0
,// union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//			boolean put = persister.getCache().insert(ck, cacheEntry);",,,unknown,no,0
,// now update all changed or added rows fks,,,unknown,no,0
,// Generate the select expression.,,,unknown,no,0
,// Add the type to the list of returned sqlResultTypes.,,,unknown,no,0
,"// remove initial "", """,,,unknown,no,0
,// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//beforeClassTokens.add(""new""); DEFINITELY DON'T HAVE THIS!!",,,unknown,no,0
,"//notAfterClassTokens.add("","");",,,unknown,no,0
,// Not elements(x),,,unknown,no,0
,// Dialect function,,,unknown,no,0
,// to be safe...,,,unknown,no,0
,// Add a space before the display text.,,,unknown,no,0
,// return,,,unknown,no,0
,// invokespecial,,,unknown,no,0
,// aload_0,,,unknown,no,0
,// aload_0,,,unknown,no,0
,// set the name of bulk accessor.,,,unknown,no,0
,// child == parent.getFirstChild(),,,unknown,no,0
,// Find or create the WHERE clause,,,unknown,no,0
,// intentionally empty,,,unknown,no,0
,//the class discriminator value,,,unknown,no,0
,// Collection 'property function',,,unknown,no,0
,// see if the entry represents a class file,,,unknown,no,0
,// the name of an entity class,,,unknown,no,0
,"// Otherwise, it's a literal.",,,unknown,no,0
,// see if the entry represents a class file,,,unknown,no,0
,// Resolve to an identity column.,,,unknown,no,0
,// IDENT is a class alias in the FROM.,,,unknown,no,0
,"// no transformations took place, so handle it as we would a // non-instrumented class",,,unknown,no,0
,"// If the constant is an IDENT, figure out what it means...",,,unknown,no,0
,// DotNode uses null here...,,,unknown,no,0
,// logic operators by definition resolve to booleans,,,unknown,no,0
,// Notify the FROM element that it is being referenced by the select.,,,unknown,no,0
,"// Resolve everything up to this dot, but don't resolve the placeholders yet.",,,unknown,no,0
,// Initialize the error handling delegate.,,,unknown,no,0
,// Should mean that no such property was found,,,unknown,no,0
,// we are already processing a dot-structure,,,unknown,no,0
,//			paramTranslations = new ParameterTranslationsImpl( collectedParameterSpecifications );,,,unknown,no,0
,"// Otherwise, we have a non-scalar select with defined collection fetch(es). // Make sure that there is only a single root entity in the return (no tuples)",,,unknown,no,0
,// PHASE 3 : Generate the SQL.,,,unknown,no,0
,"// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.",,,unknown,no,0
,// check a set of parent/child nodes in the from-clause tree // to determine if a comma is required between them,,,unknown,no,0
,"// again, both should be FromElements",,,unknown,no,0
,// these are just two unrelated table references,,,unknown,no,0
,///////////////////////////////////////////////////////////////////////,,,unknown,no,0
,// make a new one,,,unknown,no,0
,// Alias references and identifiers use the same node class.,,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,"// simple cache of param metadata based on query string.  Ideally, the // original ""user-supplied query"" string should be used to retreive this // metadata (i.e., not the para-list-expanded query string) to avoid // unnecessary cache entries. // Used solely for caching param metadata for native-sql queries, see // getSQLParameterMetadata() for a discussion as to why...",,,unknown,no,0
,// Cache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"// After that, process the JOINs. // Invoke a delegate to do the work, as this is farily complex.",,,unknown,no,0
,// select clauses for insert statements should alwasy be treated as shallow,,,unknown,no,0
,// Use the explicitly declared select expression; determine the // return types indicated by each select token,,,unknown,no,0
,// Was there an explicit select expression?,,,unknown,no,0
,// (NOT (NOT_BETWEEN a b) ) => (BETWEEN a b),,,unknown,no,0
,"// For Timestamps, we default to a separate config",,,unknown,no,0
,// Just add a 'not' parent.,,,unknown,no,0
,//foo.bars.size (also handles deprecated stuff like foo.bars.maxelement for backwardness),,,unknown,no,0
,"// Otherwise, this is a primitive type.",,,unknown,no,0
,// The property is another class..,,,unknown,no,0
,// PROPERTIES,,,unknown,no,0
,"// If this dot has already been resolved, stop now.",,,unknown,no,0
,// Prepare the left hand side and get the data type.,,,unknown,no,0
,// Prepare the left hand side and get the data type.,,,unknown,no,0
,"// The rest only matters for optimistic locking, where we // need to establish the proper data version on the region root",,,unknown,no,0
,"// For pessimistic locking, we just want to toss out our ref // to any old invalid root node and get the latest (may be null)            ",,,unknown,no,0
,// Establish the region root node with a non-locking data version,,,unknown,no,0
,// Never include subclasses for implied from elements.,,,unknown,no,0
,// inject the WHERE after the parent,,,unknown,no,0
,//    protected RegionRootListener listener;,,,unknown,no,0
,// Re-arrange the tree so that the collection function is the root and the lhs is the path.,,,unknown,no,0
,// Don't forget to resolve the argument! // Resolve the collection function now.,,,unknown,no,0
,// Start performing the deletes,,,unknown,no,0
,"// First, save off the pertinent ids, saving the number of pertinent ids for return",,,unknown,no,0
,"// check to see if the connection is in auto-commit  // mode (no connection means aggressive connection // release outside a JTA transaction context, so MUST // be autocommit mode)",,,unknown,no,0
,"// First, save off the pertinent ids, as the return value",,,unknown,no,0
,"// we do not actually propogate ANTLRExceptions as a cause, so // log it here for diagnostic purposes",,,unknown,no,0
,// switch,,,unknown,no,0
,// Delegate to the QueryLoader...,,,unknown,no,0
,// Make #@%$^#^&# sure no alias is applied to the table name,,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,"// Initialize dirty flags for arrays + collections with composite elements // and reset reached, doupdate, etc.",,,unknown,no,0
,// Show the modified AST.,,,unknown,no,0
,"//assume true, since we don't really know, and it doesn't matter",,,unknown,no,0
,//			option.setDataVersion( NonLockingDataVersion.INSTANCE );,,,unknown,no,0
,// OptimisticCache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// do nothing for persistent instances,,,unknown,no,0
,"//it does not refer to an alias of a projection, //look for a property",,,unknown,no,0
,// We ignore minimalPutOverride. JBossCache putForExternalRead is // already about as minimal as we can get; it will promptly return // if it discovers that the node we want to write to already exists,,,unknown,no,0
,// tree cache in optimistic mode seems to have as very difficult // time with remove calls on non-existent nodes (NPEs)...,,,unknown,no,0
,// Note : expected in the syntax: //      type=listenerClass //          ({sep}type=listenerClass)* // where {sep} is any whitespace or comma,,,unknown,no,0
,//the load() which takes an entity does not pass an entityName,,,unknown,no,0
,"// We have created the pool ourselves, so shut it down",,,unknown,no,0
,// Validate that an alias name was provided to determine which pool to use,,,unknown,no,0
,// Set the existing pool flag to true,,,unknown,no,0
,// long,,,unknown,no,0
,/*!persister.isCacheInvalidationRequired()*/,,,unknown,no,0
,"// get the updated snapshot of the entity state by cloning current state; // it is safe to copy in place, since by this time no-one else (should have) // has a reference  to the array",,,unknown,no,0
,// Tell the dot node about the join type.,,,unknown,no,0
,// This 'dot' expression now refers to the resulting from element.,,,unknown,no,0
,"// Among other things, updateReachables() will recursively load all // collections that are moving roles. This might cause entities to // be loaded.",,,unknown,no,0
,// a collection loaded in the current session // can not possibly be the collection belonging // to the entity passed to update(),,,unknown,no,0
,"// if a ThreadLocalSessionContext-bound session happens to get // serialized, to be completely correct, we need to make sure // that unbinding of that session occurs.",,,unknown,no,0
,// --Commented out by Inspection (12/11/04 10:56 AM): int getWarningCount();,,,unknown,no,0
,"// If there are no collection fetches, then no further checks are needed",,,unknown,no,0
,// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,//first look for a reference to a projection alias,,,unknown,no,0
,//first look for a reference to a projection alias,,,unknown,no,0
,"// We need to generate ids as part of this bulk insert. // // Note that this is only supported for sequence-style generators and // post-insert-style generators; basically, only in-db generators",,,unknown,no,0
,"// If the data type is not an association type, it could not have been in the FROM clause.",,,unknown,no,0
,"// if no array holder we found an unwrappered array (this can't occur, // because we now always call wrap() before getting to here) // return (ah==null) ? true : searchForDirtyCollections(ah, type);",,,unknown,no,0
,// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Post-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,// use the id assigned to the instance,,,unknown,no,0
,// this function has a template -> redirect output and catch the arguments,,,unknown,no,0
,"// for native-sql queries, the param metadata is determined outside // any relation to a query plan, because query plan creation and/or // retreival for a native-sql query depends on all of the return // types having been set, which might not be the case up-front when // param metadata would be most useful",,,unknown,no,0
,// Make sure that the persister is versioned,,,unknown,no,0
,"// we found some extends attributes referencing entities which were // not already processed.  here we need to locate all entity-names // and class-names contained in this document itself, making sure // that these get removed from the extendz list such that only // extends names which require us to delay processing (i.e. // external to this document and not yet processed) are contained // in the returned result",,,unknown,no,0
,"// Attach any mapping-defined ""ORDER BY"" fragments",,,unknown,no,0
,// Create a parameter specification for the collection filter...,,,unknown,no,0
,//otherwise recreate the mapping between the collection and its key,,,unknown,no,0
,// Use the delegate.,,,unknown,no,0
,"//optimistic-lock=""all"", include all updatable properties //optimistic-lock=""dirty"", include all properties we are updating this time",,,unknown,no,0
,"// nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type here",,,unknown,no,0
,"// Generate implicit joins, only if necessary.",,,unknown,no,0
,// ignore!,,,unknown,no,0
,// The standard comparator types are not Serializable but are singletons,,,unknown,no,0
,// We ensure ASYNC semantics (JBCACHE-1175),,,unknown,no,0
,"// Otherwise, use the property mapping.",,,unknown,no,0
,// will still be issued when it used to be null,,,unknown,no,0
,// Class names in the FROM clause result in a JoinSequence (the old FromParser does this).,,,unknown,no,0
,// Render the identifier select fragment using the table alias.,,,unknown,no,0
,// logic operators by definition resolve to boolean.,,,unknown,no,0
,"// Now, inject the newly built ORDER BY into the tree",,,unknown,no,0
,"// Find the WHERE; if there is no WHERE, find the FROM...",,,unknown,no,0
,// Initial load from JBC,,,unknown,no,0
,"// if there is no order by, make one",,,unknown,no,0
,// We ensure ASYNC semantics (JBCACHE-1175),,,unknown,no,0
,// return an empty Type array,,,unknown,no,0
,"// Collect the select expressions, skip the first child because it is the class name.",,,unknown,no,0
,// Invoke setScalarColumnText on each constructor argument.,,,unknown,no,0
,// Make sure that all from elements registered with this FROM clause are actually in the AST.,,,unknown,no,0
,// try the parent FromClause...,,,unknown,no,0
,// Associate the table alias with the element.,,,unknown,no,0
,// ignore it,,,unknown,no,0
,"// If the property is a special collection property name, return a CollectionPropertyMapping.",,,unknown,no,0
,"// this property belongs to the table, and it is not specifically // excluded from optimistic locking by optimistic-lock=""false""",,,unknown,no,0
,// Collection of components.,,,unknown,no,0
,// Always add the collection's query spaces.,,,unknown,no,0
,// property name is a sub-path of a component...,,,unknown,no,0
,// propertyName refers to something like collection.size...,,,unknown,no,0
,"// Do nothing, eplicit from elements are *always* in the projection list.",,,unknown,no,0
,"// Since this is an explicit FROM element, it can't be implied in the FROM clause.",,,unknown,no,0
,// If it's not implied or it is implied and it's a many to many join where the target wasn't found.,,,unknown,no,0
,// Fetch can't be used with scroll() or iterate().,,,unknown,no,0
,// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,,,unknown,no,0
,"//swaldman 2006-08-28: define c3p0-style configuration parameters for initialPoolSize, which //                     hibernate sensibly lets default to minPoolSize, but we'll let users //                     override it with the c3p0-style property if they want.",,,unknown,no,0
,// This is an explicit FROM element.,,,unknown,no,0
,//return classAlias == null ? className : classAlias;,,,unknown,no,0
,"// in non-select queries, the only time we should need to join is if we are in a subquery from clause",,,unknown,no,0
,// currently allowed...,,,unknown,no,0
,// false indicates to not generate parens around the assignment,,,unknown,no,0
,"// make sure the lhs is ""assignable""...",,,unknown,no,0
,// We need to seed the version value as part of this bulk insert,,,unknown,no,0
,//ie. 60 seconds,,,unknown,no,0
,"// local cache, so we use synchronization",,,unknown,no,0
,// construct the cache,,,unknown,no,0
,// The HQL class alias refers to the class name.,,,unknown,no,0
,// The path may be a reference to an alias defined in the parent query.,,,unknown,no,0
,"// Generated select expressions are already resolved, nothing to do.",,,unknown,no,0
,// logic operators by definition resolve to booleans,,,unknown,no,0
,// Make sure JBC doesn't look one up,,,unknown,no,0
,// Configure the cache to use our TM,,,unknown,no,0
,"// we have something like : ""? [op] rhs""",,,unknown,no,0
,"//lists, arrays //sets, maps, bags",,,unknown,no,0
,// Don't resolve the node again.,,,unknown,no,0
,"// If the lhs is a collection, use CollectionPropertyMapping",,,unknown,no,0
,// Tell the destination fromElement to 'includeSubclasses'.,,,unknown,no,0
,// Append the new property name onto the unresolved path.,,,unknown,no,0
,"// special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expression",,,unknown,no,0
,// only the identifier property field name can be a reference to the associated entity's PK...,,,unknown,no,0
,// the referenced node text is the special 'id',,,unknown,no,0
,"// we know only the lhs-hand type, so use that",,,unknown,no,0
,// otherwise (subquery case) dont reuse the fromElement if we are processing the from-clause of the subquery,,,unknown,no,0
,"// again, null != null here",,,unknown,no,0
,// aload_0,,,unknown,no,0
,"// if the from-clauses are the same, we can be a little more aggressive in terms of what we reuse",,,unknown,no,0
,// NOTE : addDuplicateAlias() already performs nullness checks on the alias.,,,unknown,no,0
,"// Here we render the select column list based on the properties defined as being generated. // For partial component generation, we currently just re-select the whole component // rather than trying to handle the individual generated portions.",,,unknown,no,0
,"//information about properties of this class, //including inherited properties //(only really needed for updatable/insertable properties)",,,unknown,no,0
,"// we finish all the ""removes"" first to take care of possible unique // constraints and so that we can take better advantage of batching",,,unknown,no,0
,"//use a combination of foreign key columns and pk columns, since //the ordering of removal and addition is not guaranteed when //a child moves from one parent to another",,,unknown,no,0
,// Make sure we don't re-release the same cache,,,unknown,no,0
,// one or the other needs to be a datetime for us to get into this method in the first place...,,,unknown,no,0
,// mutation depends on the types of nodes invloved...,,,unknown,no,0
,// This will call initialize(tok)!,,,unknown,no,0
,"// Get the function return value type, based on the type of the first argument.",,,unknown,no,0
,"// Now, set the text for this node.  It should be the element columns.",,,unknown,no,0
,"// Sometimes use the element table alias, sometimes use the... umm... collection table alias (many to many)",,,unknown,no,0
,// Add the condition to the join sequence that qualifies the indexed element.,,,unknown,no,0
,// nothing to do,,,unknown,no,0
,// #2,,,unknown,no,0
,// Get an exclusive right to update JBC for this key from this node.,,,unknown,no,0
,// We use a different delegate than the non-optimistic superclass default,,,unknown,no,0
,// Double check the distributed cache,,,unknown,no,0
,"// Don't hold the JBC node lock throughout the tx, as that // prevents updates // Add a zero (or low) timeout option so we don't block // waiting for tx's that did a put to commit",,,unknown,no,0
,// long,,,unknown,no,0
,"// If JBC is using INVALIDATION, we don't want to propagate changes. // We use the Timestamps cache to manage invalidation",,,unknown,no,0
,"// we know only the rhs-hand type, so use that",,,unknown,no,0
,//isSet = collection.isSet(); //isSorted = collection.isSorted();,,,unknown,no,0
,"// don't create a unique key, 'cos some // databases don't like a UK on nullable // columns //getCollectionTable().createUniqueKey( getIdentifier().getConstraintColumns() );",,,unknown,no,0
,"// we have something like : ""lhs [op] ?""",,,unknown,no,0
